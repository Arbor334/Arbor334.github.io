<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>页内链接</title>
      <link href="/2020/081360887.html"/>
      <url>/2020/081360887.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>使用 <code>-[你自己可以取名字](#标题名字)</code><br>  比如说  你可以取的名字是 点击  想要跳转到页内的 二级标题名为 arbor<br> 那么 应该写成<code> -[点击](# arbor)</code><br>无论是 h1~h6标题 (都只有一个#) </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Makedown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Makedown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>background</title>
      <link href="/2020/081317546.html"/>
      <url>/2020/081317546.html</url>
      
        <content type="html"><![CDATA[<h2 id="修改背景"><a href="#修改背景" class="headerlink" title="修改背景"></a>修改背景</h2><blockquote><p>我的主题是Matery </p><p>找到 themes\Matery\source\css\matery.css</p><p>搜索(ctrl+F)找到  body</p><p>修改为如下样式</p></blockquote><pre class=" language-css"><code class="language-css">body &amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* background-color: #eaeaea; */</span>    <span class="token property">background</span><span class="token punctuation">:</span> <span class="token function">linear-gradient</span><span class="token punctuation">(</span><span class="token number">60</span>deg, <span class="token function">rgba</span><span class="token punctuation">(</span><span class="token number">255</span>, <span class="token number">165</span>, <span class="token number">150</span>, <span class="token number">0.5</span><span class="token punctuation">)</span> <span class="token number">5%</span>, <span class="token function">rgba</span><span class="token punctuation">(</span><span class="token number">0</span>, <span class="token number">228</span>, <span class="token number">255</span>, <span class="token number">0.35</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">0%</span> <span class="token number">0%</span> / cover, <span class="token url">url("")</span>, <span class="token url">url("")</span> <span class="token number">0</span>px <span class="token number">0</span>px<span class="token punctuation">;</span>// url 中最好是添加在网上有的图片弄到自己的图床上    <span class="token property">background-attachment</span><span class="token punctuation">:</span> fixed<span class="token punctuation">;</span>    <span class="token property">margin</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token property">color</span><span class="token punctuation">:</span> <span class="token hexcode">#7F95D1</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树的直径</title>
      <link href="/2020/081227720.html"/>
      <url>/2020/081227720.html</url>
      
        <content type="html"><![CDATA[<h1 id="树的直径"><a href="#树的直径" class="headerlink" title="树的直径"></a>树的直径</h1><p><a href="https://www.luogu.com.cn/problem/U81904">模板题目链接</a></p><h2 id="哲学三问"><a href="#哲学三问" class="headerlink" title="哲学三问"></a>哲学三问</h2><ul><li>【1】、what ?  (什么是树的直径 )</li></ul><blockquote><p>简单来说，树上的任意两点之间的最长距离就是树的直径</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Arbor334/img/algorithm/longest_path_of_tree.jpg"></p><ul><li>【2】、why ？（为什么学习这个东西）</li></ul><blockquote><p><del>提高自己的算法能力</del>  出题会遇到，遇到了就要解决，不解决就会丢分</p></blockquote><ul><li>【3】、how ？ （怎么实现）</li></ul><blockquote><p>第一种方案 Dp：</p><blockquote><p>优点：可以处理负权边的问题</p><p>缺点：记录卡路径的信息效率低</p><p>实现过程：</p><p> 我们假设一号节点为根，“N个点N-1条边的无向图”可以看成有根树。</p><p>设d[x]表示从节点x出发走向以x为根的子树，能够到达的最远节点的距离。</p><p>设x的子节点为y1,y2,y3…, e(x,y)表示边权有</p><p>d[x]=max(d[yi]+e(x,y))</p><p>考虑对每个点x 求出经过x节点的最长链的长度F[x]，</p><p>直径就是max 1≤x≤n（F[x]）</p><p>求 F[x]: 对于x的任意两个节点 yi和yj 经过节点x的最长链的长度分四个部分： 边 (x,yi) 边 (x,yj)  yi到yi子树的最远距离 yj到yj子树的最远距离</p><p>   F[x]=max（d[yi]+d[yj]+e(x,yi)+e(x,yj)）</p><p>因为子节点将要循环到i时，d[x]存的就是从节点x出发走向</p><p>以 yj（j&lt;i）为根的子树能够到达的最远节点的距离， 就是</p><p>max（d[yj]+e(x,yj)）</p><p>我们先用 d[x]+d[yi]+e(x,yi)更新F[x]，</p><p>再用d[yi]+e(x,yi) 更新d[x]</p></blockquote><p>第二种方案 ：两次bfs</p><blockquote><p>优点：可以通过一个新的数组记录路径信息</p><p>缺点：无法处理负边权</p><p>实现流程：</p><p>【1】、从任意节点出发，通过BFS对树进行一次遍历求出与出发点距离最远的节点,记为 p</p><p>【2】、从节点 p 出发,通过 BFS 再进行一次遍历,求出与 p 距离最远的节点,记为 q。</p><p>p 是一个节点的最远的一个端点，那么从 p 出发的最远的端点就是直径的另一个端点)</p></blockquote></blockquote><h2 id="第一种解决方案-Dp"><a href="#第一种解决方案-Dp" class="headerlink" title="第一种解决方案 Dp"></a>第一种解决方案 Dp</h2><pre class=" language-c++"><code class="language-c++">#include<iostream>#include<stdio.h>#include<algorithm>using namespace std;const int N=5e6+10,M=2*N;int h[N],ver[N],ne[M],e[M],idx;bool st[N];int d[N],ans,n,x,y,z;void add(int x,int y,int z)&#123;    ver[++idx]=y,e[idx]=z,ne[idx]=h[x],h[x]=idx;&#125;void dp(int x)&#123;    st[x]=1;    for(int i=h[x];i;i=ne[i])&#123;        int y=ver[i];        if(st[y])continue; //判断是否已经经过该节点        dp(y); //继续向下寻找子节点        ans=max(ans,d[x]+d[y]+e[i]); //枚举从x节点出发的所有边，找到最远的内个        d[x]=max(d[x],d[y]+e[i]);//经过枚举后 d[x]就不一定是最长的了，要更新一下    &#125;&#125;int main()&#123;    cin>>n;    for(int i=0;i<n-1;i++)    &#123;        cin>>x>>y>>z;        add(x,y,z);        add(y,x,z);    &#125;    dp(1);    printf("%d\n",ans);&#125;</code></pre><h2 id="第二种解决方案-bfs"><a href="#第二种解决方案-bfs" class="headerlink" title="第二种解决方案 bfs"></a>第二种解决方案 bfs</h2><pre class=" language-c++"><code class="language-c++">#include<iostream>#include<stdio.h>#include<cstring>#include<queue>#include<algorithm>using namespace std;const int N=1e6+10;int h[N],dist[N],ne[N*2],e[N*2],idx,ver[N*2];int n,p,q,d,maxd;bool st[N];void add(int a,int b,int c)&#123;    ver[++idx]=b,e[idx]=c,ne[idx]=h[a],h[a]=idx;&#125;int bfs(int u)&#123;    queue<int>q;    while(!q.empty())q.pop(); //注意每次都要清空    memset(st,0,sizeof st);    memset(dist,0,sizeof dist);    q.push(u);              //把根节点推进去    int x,max_num=0;       //max_num 找到最远的节点    while(!q.empty())&#123;        x=q.front();      //取出队首        q.pop();          //抛出队首        st[x]=1;       // 这个点我走过了        for(int i=h[x];i;i=ne[i])&#123;            int y=ver[i];    //子节点            if(st[y])continue;            st[y]=1;         //没走过 就修改为走过            dist[y]=dist[x]+e[i];  //从上往下走 就要进行累加 和dp不同            if(dist[y]>maxd)&#123;   //更新最大值 和最远点                maxd=dist[y];                max_num=y;            &#125;            q.push(y);  // 每个新的节点都要加入到队列中,有可能与该节点相连的路径是比较长的        &#125;    &#125;    return max_num;  //返回最远的点&#125;int main()&#123;    scanf("%d",&n);    for(int i=1;i<n;i++)&#123;        cin>>p>>q>>d;        add(p,q,d);        add(q,p,d);    &#125;    int u=bfs(1);    int s=bfs(u);//   printf("第一次遍历得到的节点 : %d\n",u);//     printf("第二次遍历得到的节点 : %d\n",s);//     printf("最长的距离是 %d\n",maxd);    printf("%d\n",maxd);    return 0;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树的直径 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown</title>
      <link href="/2020/081217683.html"/>
      <url>/2020/081217683.html</url>
      
        <content type="html"><![CDATA[<h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><p>井号 “#” 加 一个空格” “</p><p>一直可以到6级标题</p><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><p><strong>hello，world</strong>    变成粗体 两边各加两个*号</p><p><em>hello,world</em>     变成斜体 两边各加一个*号</p><p><strong><em>hello,world</em></strong>   加粗斜体 两边各加上 ***号</p><p><del>hello,world</del>     两边各加上两个波浪号</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><blockquote><p>大于号 + 空格</p></blockquote><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><hr><p>“—“ 三个杠 就可以</p><hr><p>“***”三个星也可以</p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>![截图](C:\Users\QZJ_2020\Pictures\Saved Pictures\t017dd4fea10b244ac9.jpg)</p><blockquote><p><img src="">  感叹号   [图片的名字]   ()</p></blockquote><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><hr><p><a href="https://www.cnblogs.com/">点击进入我的博客</a></p><blockquote><p>[名字]  (链接地址)</p></blockquote><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><hr><ol><li><p>A</p></li><li><p>B</p></li><li><p>C</p><blockquote><p>“1.空格”</p></blockquote></li></ol><ul><li>A</li><li>B</li><li>C</li></ul><blockquote><p>“减号   空格  出来小点  “</p></blockquote><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><hr><table><thead><tr><th>名字</th><th>性别</th><th>生日</th></tr></thead><tbody><tr><td>张三</td><td>男</td><td>1990.1.1</td></tr></tbody></table><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> main（String args<span class="token punctuation">[</span><span class="token punctuation">]</span>）</code></pre><blockquote><p><strong>“``` “</strong>  然后加入 代码的名字  c c++  Java</p></blockquote><h2 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h2><p>输入  “$$ “ 然后回车会出现一个编辑框  按照下面的操作写就行了</p><p><a href="https://www.jianshu.com/p/cf36c5af997a">下方引用博客链接</a></p><h4 id="1-上标和下标"><a href="#1-上标和下标" class="headerlink" title="1.上标和下标"></a>1.上标和下标</h4><ul><li>下标使用符号<code>Y_1</code>表达,公式表达结果为: <img src="https://math.jianshu.com/math?formula=y_1" alt="y_1"> </li><li>上标使用 <code>X^&#123;2m&#125;</code>或者<code>X^2</code>, 其中较为复杂的表达式用<code>&#123;&#125;</code>包含, 公式表达结果为: <img src="https://math.jianshu.com/math?formula=X%5E%7B2m%7D+X%5E2" alt="X^{2m}+X^2"> </li></ul><h4 id="2-常见运算符"><a href="#2-常见运算符" class="headerlink" title="2.常见运算符"></a>2.常见运算符</h4><table><thead><tr><th>符号</th><th>表达式</th><th>符号</th><th>表达式</th><th>符号</th><th>表达式</th></tr></thead><tbody><tr><td><img src="https://math.jianshu.com/math?formula=%5Cpm" alt="\pm"></td><td>\pm</td><td><img src="https://math.jianshu.com/math?formula=%5Ctimes" alt="\times"></td><td>\times</td><td><img src="https://math.jianshu.com/math?formula=%5Cdiv" alt="\div"></td><td>\div</td></tr><tr><td><img src="https://math.jianshu.com/math?formula=%5Ccdot" alt="\cdot"></td><td>\cdot</td><td><img src="https://math.jianshu.com/math?formula=%5Cleq" alt="\leq"></td><td>\leq</td><td><img src="https://math.jianshu.com/math?formula=%5Cgeq" alt="\geq"></td><td>\geq</td></tr><tr><td><img src="https://math.jianshu.com/math?formula=%5Cneq" alt="\neq"></td><td>\neq</td><td><img src="https://math.jianshu.com/math?formula=%5Capprox" alt="\approx"></td><td>\approx</td><td><img src="https://math.jianshu.com/math?formula=%5Cequiv" alt="\equiv"></td><td>\equiv</td></tr><tr><td><img src="https://math.jianshu.com/math?formula=%5Cin" alt="\in"></td><td>\in</td><td><img src="https://math.jianshu.com/math?formula=%5Cnotin" alt="\notin"></td><td>\notin</td><td><img src="https://math.jianshu.com/math?formula=%5Csubset" alt="\subset"></td><td>\subset</td></tr><tr><td><img src="https://math.jianshu.com/math?formula=%5Csupset" alt="\supset"></td><td>\supset</td><td><img src="https://math.jianshu.com/math?formula=%5Cbigcap" alt="\bigcap"></td><td>\bigcap</td><td><img src="https://math.jianshu.com/math?formula=%5Cbigcup" alt="\bigcup"></td><td>\bigcup</td></tr></tbody></table><h4 id="3-特殊符号"><a href="#3-特殊符号" class="headerlink" title="3.特殊符号"></a>3.特殊符号</h4><ul><li>求和符号: 使用<code>\sum</code> 转义表达求和符号,下限符号使用<code>_&#123;m&#125;</code>,上限符号使用<code>^\infty</code>, 如:  <img src="https://math.jianshu.com/math?formula=%5Csum_%7Bm=0%7D%5E%5Cinfty" alt="\sum_{m=0}^\infty"> </li><li>积分符号: <code>\int_0^1</code>转义表达积分符号, 如: <img src="https://math.jianshu.com/math?formula=%5Cint_0%5E1" alt="\int_0^1"> </li><li>极限符号: <code>\lim_&#123;变量 \to 表达式&#125; 表达式</code>, 如 <img src="https://math.jianshu.com/math?formula=%5Clim_%7B1%20%5Cto%205%7D%20%E8%A1%A8%E8%BE%BE%E5%BC%8F" alt="\lim_{1 \to 5} 表达式"> </li><li>向量符号: <code>\vec&#123;a&#125;</code>转义表达向量, 如: <img src="https://math.jianshu.com/math?formula=%5Cvec%7Ba%7D" alt="\vec{a}"> </li><li>空格符号: markdown支持四种空格<code>\, 、\;、\quad 和 \qquad</code> </li></ul><h4 id="4-希腊字母的大小写"><a href="#4-希腊字母的大小写" class="headerlink" title="4.希腊字母的大小写"></a>4.希腊字母的大小写</h4><p>希腊字母的大写使用首字母大写<code>\Gamma</code>转义,小写使用首字母小写<code>\gamma</code>转义, 公式表达结果为: <img src="https://math.jianshu.com/math?formula=%5CGamma" alt="\Gamma">  和   <img src="https://math.jianshu.com/math?formula=%5Cgamma" alt="\gamma"></p><h4 id="5-关于注释"><a href="#5-关于注释" class="headerlink" title="5.关于注释"></a>5.关于注释</h4><ul><li>公式注释: 使用<code>\text&#123;内容&#125;</code>转义注释,公式表达结果为: <img src="https://math.jianshu.com/math?formula=%5Ctext%20%7B%E5%85%AC%E5%BC%8F%E6%B3%A8%E9%87%8A%7D" alt="\text {公式注释}"> </li><li>文字颜色: 使用<code>\color&#123;颜色&#125;&#123;文字&#125;</code>转义表达带颜色的文字,公式表达结果为:  <img src="https://math.jianshu.com/math?formula=%5Ccolor%7Bgreen%7D%7B%E6%96%87%E5%AD%97%7D" alt="\color{green}{文字}"> </li></ul><h4 id="6-分数"><a href="#6-分数" class="headerlink" title="6.分数"></a>6.分数</h4><p>分数使用<code>\frac&#123;part I&#125;&#123;part II&#125;</code>转义表达,公式表达结果为: <img src="https://math.jianshu.com/math?formula=%5Cfrac%7B(-1)%5Em%7D%7Bm!(m%20+%201)%7D" alt="\frac{(-1)^m}{m!(m + 1)}"></p><h4 id="7-公式中的大括号或大分隔符"><a href="#7-公式中的大括号或大分隔符" class="headerlink" title="7.公式中的大括号或大分隔符"></a>7.公式中的大括号或大分隔符</h4><ul><li>在配对符号中.如公式中的括号使用<code>\left(</code>表达左括号,使用<code>\right)</code>转义表达向右的括号;如: <img src="https://math.jianshu.com/math?formula=%5Cleft(%7B%5Cfrac%7Bx%7D%7B2%7D%20%7D%5Cright)" alt="\left({\frac{x}{2} }\right)"> </li><li>在非配对符号中以<code>\left. 其他 \right符号</code> 或 <code>\left符号 其他 \right.</code> 表非配对的较大符号.如: <img src="https://math.jianshu.com/math?formula=%5Cleft.%5Cfrac%7Bdu%7D%7Bdx%7D%5Cright%7C_%7Bx=0%7D" alt="\left.\frac{du}{dx}\right|_{x=0}"> </li><li>注: 转义表达不需要<code>&#123; 和 &#125;</code> </li></ul><h4 id="8-上划线与下划线"><a href="#8-上划线与下划线" class="headerlink" title="8.上划线与下划线"></a>8.上划线与下划线</h4><p>上划线使用<code>\overline&#123;&#125;</code>转义表达,下划线使用<code>\underline&#123;&#125;</code>转义表达,公式表达结果为: <img src="https://math.jianshu.com/math?formula=%5Coverline%7Ba+b+c+d%7D" alt="\overline{a+b+c+d}">和<img src="https://math.jianshu.com/math?formula=%5Cunderline%7Ba+b+c+d%7D" alt="\underline{a+b+c+d}"></p><h4 id="9-开根号"><a href="#9-开根号" class="headerlink" title="9.开根号"></a>9.开根号</h4><p>多次方根使用<code>\sqrt[n]&#123;x&#125;</code>,其中<code>n</code>表示根的次数,<code>x</code>表示被开方项,公式表达结果为: <img src="https://math.jianshu.com/math?formula=%5Csqrt%5Bn%5D%7B3%7D" alt="\sqrt[n]{3}"></p><h4 id="10-方程组"><a href="#10-方程组" class="headerlink" title="10.方程组"></a>10.方程组</h4><p>1.表达方式一: 使用<code>\begin&#123;array&#125;&#123;c&#125; 表达式一\\表达式二... \end&#123;array&#125;</code><br> <img src="https://math.jianshu.com/math?formula=%5Cleft%5C%7B%20%5Cbegin%7Barray%7D%20%7Ba%7D%20a_1x+b_1y+c_1z=d_1%20%5C%5C%20a_2x+b_2y+c_2z=d_2%20%5Cend%7Barray%7D%20%5Cright." alt="\left\{ \begin{array} {a} a_1x+b_1y+c_1z=d_1 \\ a_2x+b_2y+c_2z=d_2 \end{array} \right."><br> 2.表达方式二: 使用<code>\begin&#123;cases&#125;…\end&#123;cases&#125;</code><br> <img src="https://math.jianshu.com/math?formula=f(n)%20=%20%5Cbegin%7Bcases%7D%20%5Cfrac%7Bn%7D%7B2%7D,%20&%20%5Ctext%7Bif%20$n$%20is%20even%7D%20%5C%5C%5B2ex%5D%203n+1,%20&%20%5Ctext%7Bif%20$n$%20is%20odd%7D%20%5Cend%7Bcases%7D" alt="f(n) = \begin{cases} \frac{n}{2}, &amp; \text{if $n$ is even} \[2ex] 3n+1, &amp; \text{if $n$ is odd} \end{cases}"><br> 注: 关于<code>\\[2ex]</code>一个 [ex] 指一个 “X-Height”，即x字母高度。可以根据情况指定多个 [ex]，如 [3ex]、[4ex] 等。 其实可以在任何地方使用 [2ex] 语句，只要你觉得合适。</p><h4 id="12-使用HTML语法表达数学公式"><a href="#12-使用HTML语法表达数学公式" class="headerlink" title="12.使用HTML语法表达数学公式"></a>12.使用HTML语法表达数学公式</h4><ul><li>上标与下标的表达: 使用标签<code>&lt;sub&gt;</code>和<code>&lt;sup&gt;</code>表达, 表达结果为: text 与text </li><li>上划线表达: 使用标签<code>&lt;SPAN style=&quot;TEXT-DECORATION: overline&quot;&gt;X&lt;/SPAN&gt;</code>表达,表达结果为: <SPAN style="TEXT-DECORATION: overline">X</SPAN></li></ul><h4 id="13-补充"><a href="#13-补充" class="headerlink" title="13.补充"></a>13.补充</h4><p>对于部分符号无法用 markdown 的公式表达,可以使用 <code>\符号</code> 转义表达,如 <img src="https://math.jianshu.com/math?formula=%5C%25" alt="\%">等</p><p>作者：地平线上的背影</p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BFS</title>
      <link href="/2020/081218898.html"/>
      <url>/2020/081218898.html</url>
      
        <content type="html"><![CDATA[<h1 id="bfs模板"><a href="#bfs模板" class="headerlink" title="bfs模板"></a>bfs模板</h1><pre class=" language-c++"><code class="language-c++">const int N=10010;//看数据多大pair<int,int> q[N];#define x first#define y firstbool st[N][N];int g[N][N];int dx[4]=&#123;&#125;,dy[4]=&#123;&#125;;int bfs(int n,int m)&#123;  int hh=0,tt=0;  q[0]=&#123;&#125;;//这里面存的是一个点 具体问题具体分析  st[][]=true;//最开始的一个点遍历过了  while(hh<=tt)&#123;pair<int,int> t=q[hh++];    for(int i=0;i<4;i++)&#123;      int x=t.x+dx[i],y=t.y+dy[i];      if(check())//不满足的条件就跳过        continue;      q[++tt]=&#123;x,y&#125;;//新加入队列      st[x][y]=true;//标记访问过    &#125;  &#125;&#125;int main()&#123;&#125;</code></pre><h2 id="抓住那头牛"><a href="#抓住那头牛" class="headerlink" title="抓住那头牛"></a>抓住那头牛</h2><p><a href="https://www.acwing.com/problem/content/1102/">题目链接</a></p><pre class=" language-c++"><code class="language-c++">农夫知道一头牛的位置，想要抓住它。农夫和牛都位于数轴上，农夫起始位于点 N，牛位于点 K。农夫有两种移动方式：从 X 移动到 X−1 或 X+1，每次移动花费一分钟从 X 移动到 2∗X，每次移动花费一分钟假设牛没有意识到农夫的行动，站在原地不动。农夫最少要花多少时间才能抓住牛？输入格式共一行，包含两个整数N和K。输出格式输出一个整数，表示抓到牛所花费的最少时间。数据范围0≤N,K≤105输入样例：5 17输出样例：4</code></pre><pre class=" language-c++"><code class="language-c++">#include<iostream>#include<stdio.h>#include<cstring>using namespace std;const int N=2e5+10;int dist[N];int q[N];int n,k;int bfs()&#123;    memset(dist,-1,sizeof dist);    dist[n]=0;    int hh=0,tt=0;    q[0]=n;    while(hh<=tt)&#123;        int t=q[hh++];        if(t==k) return dist[t];        if(t+1<N&&dist[t+1]==-1)        &#123;            dist[t+1]=dist[t]+1;            q[++tt]=t+1;        &#125;        if(t-1>=0&&dist[t-1]==-1)        &#123;            dist[t-1]=dist[t]+1;            q[++tt]=t-1;        &#125;        if(t*2<N&&dist[t*2]==-1)        &#123;            dist[t*2]=dist[t]+1;            q[++tt]=2*t;;        &#125;    &#125;    return 0;&#125;int main()&#123;    cin>>n>>k; printf("%d\n",bfs());&#125;</code></pre><h2 id="走迷宫"><a href="#走迷宫" class="headerlink" title="走迷宫"></a>走迷宫</h2><p><a href="https://www.acwing.com/problem/content/846/">题目链接</a></p><pre class=" language-c"><code class="language-c">给定一个n<span class="token operator">*</span>m的二维整数数组，用来表示一个迷宫，数组中只包含<span class="token number">0</span>或<span class="token number">1</span>，其中<span class="token number">0</span>表示可以走的路，<span class="token number">1</span>表示不可通过的墙壁。最初，有一个人位于左上角<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>处，已知该人每次可以向上、下、左、右任意一个方向移动一个位置。请问，该人从左上角移动至右下角<span class="token punctuation">(</span>n<span class="token punctuation">,</span> m<span class="token punctuation">)</span>处，至少需要移动多少次。数据保证<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>处和<span class="token punctuation">(</span>n<span class="token punctuation">,</span> m<span class="token punctuation">)</span>处的数字为<span class="token number">0</span>，且一定至少存在一条通路。输入格式第一行包含两个整数n和m。接下来n行，每行包含m个整数（<span class="token number">0</span>或<span class="token number">1</span>），表示完整的二维数组迷宫。输出格式输出一个整数，表示从左上角移动至右下角的最少移动次数。数据范围<span class="token number">1</span>≤n<span class="token punctuation">,</span>m≤<span class="token number">100</span>输入样例：<span class="token number">5</span> <span class="token number">5</span><span class="token number">0</span> <span class="token number">1</span> <span class="token number">0</span> <span class="token number">0</span> <span class="token number">0</span><span class="token number">0</span> <span class="token number">1</span> <span class="token number">0</span> <span class="token number">1</span> <span class="token number">0</span><span class="token number">0</span> <span class="token number">0</span> <span class="token number">0</span> <span class="token number">0</span> <span class="token number">0</span><span class="token number">0</span> <span class="token number">1</span> <span class="token number">1</span> <span class="token number">1</span> <span class="token number">0</span><span class="token number">0</span> <span class="token number">0</span> <span class="token number">0</span> <span class="token number">1</span> <span class="token number">0</span>输出样例：<span class="token number">8</span></code></pre><pre class=" language-c++"><code class="language-c++">#include<cstdio>#include<iostream>#include<queue>using namespace std;int nx[4] = &#123;-1,1,0,0&#125;,ny[4] = &#123;0,0,-1,1&#125;,g[110][110];int step[110][110];pair<int,int> q[110*110];int bfs(int n,int m)&#123;    int hh=0,tt=0;    q[0]=&#123;0,0&#125;;    while(hh<=tt)&#123;        auto t = q[hh++];        int k = step[t.first][t.second];        if(t.first==n-1&&t.second==m-1) return k;        for(int i = 0;i < 4;i++)&#123;            int x = t.first + nx[i],y = t.second + ny[i];            if(step[x][y]==0&&g[x][y]==0&&x>=0&&y>=0&&x<n&&y<m)&#123;             q[++tt]=&#123;x,y&#125;;                step[x][y] = k+1;            &#125;        &#125;    &#125;&#125;int main()&#123;    int n,m;    cin>>n>>m;    for(int i = 0;i < n;i++)&#123;        for(int j = 0;j <m;j++)&#123;            cin>>g[i][j];        &#125;    &#125;    printf("%d\n",bfs(n,m));&#125;</code></pre><h2 id="迷宫问题"><a href="#迷宫问题" class="headerlink" title="迷宫问题"></a>迷宫问题</h2><p><a href="https://www.acwing.com/problem/content/1078/">题目链接</a></p><pre><code>给定一个 n×n 的二维数组，如下所示：int maze[5][5] = &amp;#123;0, 1, 0, 0, 0,0, 1, 0, 1, 0,0, 0, 0, 0, 0,0, 1, 1, 1, 0,0, 0, 0, 1, 0,&amp;#125;;它表示一个迷宫，其中的1表示墙壁，0表示可以走的路，只能横着走或竖着走，不能斜着走，要求编程序找出从左上角到右下角的最短路线。数据保证至少存在一条从左上角走到右下角的路径。输入格式第一行包含整数 n。接下来 n 行，每行包含 n 个整数 0 或 1，表示迷宫。输出格式输出从左上角到右下角的最短路线，如果答案不唯一，输出任意一条路径均可。按顺序，每行输出一个路径中经过的单元格的坐标，左上角坐标为 (0,0)，右下角坐标为 (n−1,n−1)。数据范围0≤n≤1000输入样例：50 1 0 0 00 1 0 1 00 0 0 0 00 1 1 1 00 0 0 1 0输出样例：0 01 02 02 12 22 32 43 44 4</code></pre><pre class=" language-c++"><code class="language-c++">#include<iostream>#include<stdio.h>using namespace std;const int N=1010,M=N*N;int a[N][N],n;#define x first#define y secondbool st[N][N];pair<int,int> q[M];pair<int,int> pre[N][N];int dx[4]=&#123;-1,1,0,0&#125;,dy[4]=&#123;0,0,-1,1&#125;;void bfs()&#123;    int hh=0,tt=0;    q[0]=&#123;n-1,n-1&#125;;    st[n-1][n-1]=true;    while(hh<=tt)&#123;        pair<int,int> t=q[hh++];        for(int i=0;i<4;i++)        &#123;            int c=t.x+dx[i],d=t.y+dy[i];            if(a[c][d]==1||c<0||c>=n||d>=n||d<0||st[c][d]==true)continue;            q[++tt]=&#123;c,d&#125;;            pre[c][d]=&#123;t.x,t.y&#125;;            st[c][d]=true;        &#125;    &#125;&#125;int main()&#123;    cin>>n;    for(int i=0;i<n;i++)    for(int j=0;j<n;j++)    cin>>a[i][j];    bfs();    pair<int,int> end=&#123;0,0&#125;;    printf("0 0\n");    while(end.x!=n-1||end.y!=n-1)&#123;        printf("%d %d\n",pre[end.x][end.y].x,pre[end.x][end.y].y);        int x=end.x,y=end.y;        end.x=pre[x][y].x,end.y=pre[x][y].y;    &#125;    return 0;&#125;</code></pre><h2 id="武士风度的牛"><a href="#武士风度的牛" class="headerlink" title="武士风度的牛"></a>武士风度的牛</h2><p><a href="https://www.acwing.com/problem/content/190/">题目链接</a></p><pre class=" language-c"><code class="language-c">农民John有很多牛，他想交易其中一头被Don称为The Knight的牛。这头牛有一个独一无二的超能力，在农场里像Knight一样地跳（就是我们熟悉的象棋中马的走法）。虽然这头神奇的牛不能跳到树上和石头上，但是它可以在牧场上随意跳，我们把牧场用一个x，y的坐标图来表示。这头神奇的牛像其它牛一样喜欢吃草，给你一张地图，上面标注了The Knight的开始位置，树、灌木、石头以及其它障碍的位置，除此之外还有一捆草。现在你的任务是，确定The Knight要想吃到草，至少需要跳多少次。The Knight的位置用’K’来标记，障碍的位置用’<span class="token operator">*</span>’来标记，草的位置用’H’来标记。这里有一个地图的例子：             <span class="token number">11</span> <span class="token operator">|</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span>             <span class="token number">10</span> <span class="token operator">|</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token operator">*</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span>              <span class="token number">9</span> <span class="token operator">|</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span>              <span class="token number">8</span> <span class="token operator">|</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token operator">*</span> <span class="token punctuation">.</span> <span class="token operator">*</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span>              <span class="token number">7</span> <span class="token operator">|</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token operator">*</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span>              <span class="token number">6</span> <span class="token operator">|</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token operator">*</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token operator">*</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> H              <span class="token number">5</span> <span class="token operator">|</span> <span class="token operator">*</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span>              <span class="token number">4</span> <span class="token operator">|</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token operator">*</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token operator">*</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span>              <span class="token number">3</span> <span class="token operator">|</span> <span class="token punctuation">.</span> K <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span>              <span class="token number">2</span> <span class="token operator">|</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token operator">*</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token operator">*</span>              <span class="token number">1</span> <span class="token operator">|</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token operator">*</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token operator">*</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span>              <span class="token number">0</span> <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>                                    <span class="token number">1</span>                <span class="token number">0</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span> <span class="token number">7</span> <span class="token number">8</span> <span class="token number">9</span> <span class="token number">0</span>The Knight 可以按照下图中的A<span class="token punctuation">,</span>B<span class="token punctuation">,</span>C<span class="token punctuation">,</span>D…这条路径用<span class="token number">5</span>次跳到草的地方（有可能其它路线的长度也是<span class="token number">5</span>）：             <span class="token number">11</span> <span class="token operator">|</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span>             <span class="token number">10</span> <span class="token operator">|</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token operator">*</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span>              <span class="token number">9</span> <span class="token operator">|</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span>              <span class="token number">8</span> <span class="token operator">|</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token operator">*</span> <span class="token punctuation">.</span> <span class="token operator">*</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span>              <span class="token number">7</span> <span class="token operator">|</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token operator">*</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span>              <span class="token number">6</span> <span class="token operator">|</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token operator">*</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token operator">*</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> F<span class="token operator">&lt;</span>              <span class="token number">5</span> <span class="token operator">|</span> <span class="token operator">*</span> <span class="token punctuation">.</span> B <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span>              <span class="token number">4</span> <span class="token operator">|</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token operator">*</span> C <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token operator">*</span> E <span class="token punctuation">.</span>              <span class="token number">3</span> <span class="token operator">|</span> <span class="token punctuation">.</span><span class="token operator">></span>A <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> D <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span>              <span class="token number">2</span> <span class="token operator">|</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token operator">*</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token operator">*</span>              <span class="token number">1</span> <span class="token operator">|</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token operator">*</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token operator">*</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span>              <span class="token number">0</span> <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>                                    <span class="token number">1</span>                <span class="token number">0</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span> <span class="token number">7</span> <span class="token number">8</span> <span class="token number">9</span> <span class="token number">0</span>注意： 数据保证一定有解。输入格式第<span class="token number">1</span>行： 两个数，表示农场的列数<span class="token function">C</span><span class="token punctuation">(</span>C<span class="token operator">&lt;=</span><span class="token number">150</span><span class="token punctuation">)</span>和行数<span class="token function">R</span><span class="token punctuation">(</span>R<span class="token operator">&lt;=</span><span class="token number">150</span><span class="token punctuation">)</span>。第<span class="token number">2</span><span class="token punctuation">.</span><span class="token punctuation">.</span>R<span class="token operator">+</span><span class="token number">1</span>行<span class="token punctuation">:</span> 每行一个由C个字符组成的字符串，共同描绘出牧场地图。输出格式一个整数，表示跳跃的最小次数。输入样例：<span class="token number">10</span> <span class="token number">11</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">*</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">*</span><span class="token punctuation">.</span><span class="token operator">*</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">*</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">*</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">*</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>H<span class="token operator">*</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">*</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">*</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>K<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">*</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">*</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">*</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">*</span><span class="token punctuation">.</span><span class="token punctuation">.</span>输出样例：<span class="token number">5</span></code></pre><pre class=" language-c++"><code class="language-c++">#include<iostream>#include<algorithm>#include<stdio.h>#include<cstring>using namespace std;int n,m;#define x first#define y secondconst int N=200,M=N*N;char g[N][N];int map[N][N];pair<int,int> q[M],st,ed;int ans=0;int dx[8]=&#123;-1,-2,-2,-1,1,2,2,1&#125;,dy[8]=&#123;-2,-1,1,2,2,1,-1,-2&#125;;int bfs()&#123;    int hh=0,tt=0;    memset(map,-1,sizeof map);    q[0]=&#123;st.x,st.y&#125;;    map[st.x][st.y]=0;   while(hh<=tt)&#123;       pair<int,int> t=q[hh++];       int ans=map[t.x][t.y];       if(t.x==ed.x&&t.y==ed.y) return map[t.x][t.y];       for(int i =0;i<8;i++)&#123;          int c=t.x+dx[i],d=t.y+dy[i];           if(map[c][d]!=-1||c<0||c>=n||d<0||d>=m||g[c][d]=='*')continue;           q[++tt]=&#123;c,d&#125;;           map[c][d]=map[t.x][t.y]+1;       &#125;   &#125;    return 0;&#125;int main()&#123;    cin>>m>>n;    for(int i=0;i<n;i++)    for(int j=0;j<m;j++)&#123;    cin>>g[i][j];    if(g[i][j]=='K')    st.x=i,st.y=j;    if(g[i][j]=='H')    ed.x=i,ed.y=j;    &#125;   printf("%d\n",bfs());&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithmBFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>prim</title>
      <link href="/2020/081126197.html"/>
      <url>/2020/081126197.html</url>
      
        <content type="html"><![CDATA[<h1 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h1><p><a href="https://www.acwing.com/problem/content/860/">模板题木链接</a></p><h2 id="Prim算法概括"><a href="#Prim算法概括" class="headerlink" title="Prim算法概括"></a>Prim算法概括</h2><blockquote><p>文字来源 蓝书 【算法竞赛进阶指南】</p><p>Prim算法总是维护最小生成树的一部分</p><p>适用于稠密图，尤其是完全图的最小生成树的求解</p><p>最初，只确定1号节点属于最小生成树</p><p>任意时间，设已经确定属于最小生成树节点的集合为T<br>                                         省余节点的集合为S</p><p>Prim找到 min x∈T，y∈S {z}</p><p>即：两个端点分别属于 S,T的权值的最小边，</p><p>把x从集合S 中删除，加入集合T中，并把 z 加入到答案中</p><p>维护数组d[], 若x∈S，d[x]表示节点x和节点T中的节点之间的权值的最小边。若x属于T，d[x]表示x被加入T是选出的最小边的权值</p></blockquote><h2 id="prim算法流程"><a href="#prim算法流程" class="headerlink" title="prim算法流程"></a>prim算法流程</h2><blockquote><p>【1】、先把数组d 赋值为正无穷</p><p>【2】、遍历n次 每次找到结合S中距离最近的点复制给 t</p><p>【3】、v[t]=true t边用过了</p><p>【4】、用 t 更新其他点到集合的距离</p></blockquote><h2 id="prim朴素算法代码"><a href="#prim朴素算法代码" class="headerlink" title="prim朴素算法代码"></a>prim朴素算法代码</h2><pre class=" language-c++"><code class="language-c++">using namespace std;const int N=3010;int a[N][N],d[N],n,m,ans;bool v[N];void prim()&#123;    memset(d,0x3f,sizeof d);    memset(v,0,sizeof v);    d[1]=0; //第一个点可以默认在T集合中    for(int i=1;i<n;i++)&#123; //遍历n次        int x=0;        for(int j=1;j<=n;j++)        if(!v[j]&&(x==0||d[j]<d[x]))x=j; //找到最小权值            v[x]=1; //x这个最小权值边用过了            for(int y=1;y<=n;y++) //更新点到集合T的距离            if(!v[y])d[y]=min(d[y],a[x][y]);    &#125;&#125;int main()&#123;    cin>>n>>m;    memset(a,0x3f,sizeof a); //用邻接矩阵存储 初始化都是不通的    for(int i=1;i<=n;i++) a[i][i]=0; //自己到自己为0    for(int i=1;i<=m;i++)    &#123; int x,y,z;        cin>>x>>y>>z;        a[x][y]=a[y][x]=min(a[x][y],z); //无向图 所以 x->y y->x都要存    &#125;    prim();    for(int i=2;i<=n;i++)ans+=d[i]; //d就是prim以后每次加如集合T的最小权值     if(ans>4990000) //(500-1)*10000     printf("impossible\n");    else    printf("%d\n",ans);&#125;</code></pre><blockquote><p>等待更新</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
