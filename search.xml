<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>树的直径</title>
      <link href="/2020/081227720.html"/>
      <url>/2020/081227720.html</url>
      
        <content type="html"><![CDATA[<h1 id="树的直径"><a href="#树的直径" class="headerlink" title="树的直径"></a>树的直径</h1><p><a href="https://www.luogu.com.cn/problem/U81904">模板题目链接</a></p><h2 id="哲学三问"><a href="#哲学三问" class="headerlink" title="哲学三问"></a>哲学三问</h2><ul><li>【1】、what ?  (什么是树的直径 )</li></ul><blockquote><p>简单来说，树上的任意两点之间的最长距离就是树的直径</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Arbor334/img/algorithm/longest_path_of_tree.jpg"></p><ul><li>【2】、why ？（为什么学习这个东西）</li></ul><blockquote><p><del>提高自己的算法能力</del>  出题会遇到，遇到了就要解决，不解决就会丢分</p></blockquote><ul><li>【3】、how ？ （怎么实现）</li></ul><blockquote><p>第一种方案 Dp：</p><blockquote><p>优点：可以处理负权边的问题</p><p>缺点：记录卡路径的信息效率低</p><p>实现过程：</p><p> 我们假设一号节点为根，“N个点N-1条边的无向图”可以看成有根树。</p><p>设d[x]表示从节点x出发走向以x为根的子树，能够到达的最远节点的距离。</p><p>设x的子节点为y1,y2,y3…, e(x,y)表示边权有</p><p>d[x]=max(d[yi]+e(x,y))</p><p>考虑对每个点x 求出经过x节点的最长链的长度F[x]，</p><p>直径就是max 1≤x≤n（F[x]）</p><p>求 F[x]: 对于x的任意两个节点 yi和yj 经过节点x的最长链的长度分四个部分： 边 (x,yi) 边 (x,yj)  yi到yi子树的最远距离 yj到yj子树的最远距离</p><p>   F[x]=max（d[yi]+d[yj]+e(x,yi)+e(x,yj)）</p><p>因为子节点将要循环到i时，d[x]存的就是从节点x出发走向</p><p>以 yj（j&lt;i）为根的子树能够到达的最远节点的距离， 就是</p><p>max（d[yj]+e(x,yj)）</p><p>我们先用 d[x]+d[yi]+e(x,yi)更新F[x]，</p><p>再用d[yi]+e(x,yi) 更新d[x]</p></blockquote><p>第二种方案 ：两次bfs</p><blockquote><p>优点：可以通过一个新的数组记录路径信息</p><p>缺点：无法处理负边权</p><p>实现流程：</p><p>【1】、从任意节点出发，通过BFS对树进行一次遍历求出与出发点距离最远的节点,记为 p</p><p>【2】、从节点 p 出发,通过 BFS 再进行一次遍历,求出与 p 距离最远的节点,记为 q。</p><p>p 是一个节点的最远的一个端点，那么从 p 出发的最远的端点就是直径的另一个端点)</p></blockquote></blockquote><h2 id="第一种解决方案-Dp"><a href="#第一种解决方案-Dp" class="headerlink" title="第一种解决方案 Dp"></a>第一种解决方案 Dp</h2><pre class=" language-c++"><code class="language-c++">#include<iostream>#include<stdio.h>#include<algorithm>using namespace std;const int N=5e6+10,M=2*N;int h[N],ver[N],ne[M],e[M],idx;bool st[N];int d[N],ans,n,x,y,z;void add(int x,int y,int z)&#123;    ver[++idx]=y,e[idx]=z,ne[idx]=h[x],h[x]=idx;&#125;void dp(int x)&#123;    st[x]=1;    for(int i=h[x];i;i=ne[i])&#123;        int y=ver[i];        if(st[y])continue; //判断是否已经经过该节点        dp(y); //继续向下寻找子节点        ans=max(ans,d[x]+d[y]+e[i]); //枚举从x节点出发的所有边，找到最远的内个        d[x]=max(d[x],d[y]+e[i]);//经过枚举后 d[x]就不一定是最长的了，要更新一下    &#125;&#125;int main()&#123;    cin>>n;    for(int i=0;i<n-1;i++)    &#123;        cin>>x>>y>>z;        add(x,y,z);        add(y,x,z);    &#125;    dp(1);    printf("%d\n",ans);&#125;</code></pre><h2 id="第二种解决方案-bfs"><a href="#第二种解决方案-bfs" class="headerlink" title="第二种解决方案 bfs"></a>第二种解决方案 bfs</h2><pre class=" language-c++"><code class="language-c++">#include<iostream>#include<stdio.h>#include<cstring>#include<queue>#include<algorithm>using namespace std;const int N=1e6+10;int h[N],dist[N],ne[N*2],e[N*2],idx,ver[N*2];int n,p,q,d,maxd;bool st[N];void add(int a,int b,int c)&#123;    ver[++idx]=b,e[idx]=c,ne[idx]=h[a],h[a]=idx;&#125;int bfs(int u)&#123;    queue<int>q;    while(!q.empty())q.pop(); //注意每次都要清空    memset(st,0,sizeof st);    memset(dist,0,sizeof dist);    q.push(u);              //把根节点推进去    int x,max_num=0;       //max_num 找到最远的节点    while(!q.empty())&#123;        x=q.front();      //取出队首        q.pop();          //抛出队首        st[x]=1;       // 这个点我走过了        for(int i=h[x];i;i=ne[i])&#123;            int y=ver[i];    //子节点            if(st[y])continue;            st[y]=1;         //没走过 就修改为走过            dist[y]=dist[x]+e[i];  //从上往下走 就要进行累加 和dp不同            if(dist[y]>maxd)&#123;   //更新最大值 和最远点                maxd=dist[y];                max_num=y;            &#125;            q.push(y);  // 每个新的节点都要加入到队列中,有可能与该节点相连的路径是比较长的        &#125;    &#125;    return max_num;  //返回最远的点&#125;int main()&#123;    scanf("%d",&n);    for(int i=1;i<n;i++)&#123;        cin>>p>>q>>d;        add(p,q,d);        add(q,p,d);    &#125;    int u=bfs(1);    int s=bfs(u);//   printf("第一次遍历得到的节点 : %d\n",u);//     printf("第二次遍历得到的节点 : %d\n",s);//     printf("最长的距离是 %d\n",maxd);    printf("%d\n",maxd);    return 0;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树的直径 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown</title>
      <link href="/2020/081217683.html"/>
      <url>/2020/081217683.html</url>
      
        <content type="html"><![CDATA[<h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><p>井号 “#” 加 一个空格” “</p><p>一直可以到6级标题</p><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><p><strong>hello，world</strong>    变成粗体 两边各加两个*号</p><p><em>hello,world</em>     变成斜体 两边各加一个*号</p><p><strong><em>hello,world</em></strong>   加粗斜体 两边各加上 ***号</p><p><del>hello,world</del>     两边各加上两个波浪号</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><blockquote><p>大于号 + 空格</p></blockquote><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><hr><p>“—“ 三个杠 就可以</p><hr><p>“***”三个星也可以</p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>![截图](C:\Users\QZJ_2020\Pictures\Saved Pictures\t017dd4fea10b244ac9.jpg)</p><blockquote><p><img src="">  感叹号   [图片的名字]   ()</p></blockquote><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><hr><p><a href="https://www.cnblogs.com/">点击进入我的博客</a></p><blockquote><p>[名字]  (链接地址)</p></blockquote><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><hr><ol><li><p>A</p></li><li><p>B</p></li><li><p>C</p><blockquote><p>“1.空格”</p></blockquote></li></ol><ul><li>A</li><li>B</li><li>C</li></ul><blockquote><p>“减号   空格  出来小点  “</p></blockquote><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><hr><table><thead><tr><th>名字</th><th>性别</th><th>生日</th></tr></thead><tbody><tr><td>张三</td><td>男</td><td>1990.1.1</td></tr></tbody></table><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> main（String args<span class="token punctuation">[</span><span class="token punctuation">]</span>）</code></pre><blockquote><p><strong>“``` “</strong>  然后加入 代码的名字  c c++  Java</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BFS</title>
      <link href="/2020/081218898.html"/>
      <url>/2020/081218898.html</url>
      
        <content type="html"><![CDATA[<h1 id="bfs模板"><a href="#bfs模板" class="headerlink" title="bfs模板"></a>bfs模板</h1><pre class=" language-c++"><code class="language-c++">const int N=10010;//看数据多大pair<int,int> q[N];#define x first#define y firstbool st[N][N];int g[N][N];int dx[4]=&#123;&#125;,dy[4]=&#123;&#125;;int bfs(int n,int m)&#123;  int hh=0,tt=0;  q[0]=&#123;&#125;;//这里面存的是一个点 具体问题具体分析  st[][]=true;//最开始的一个点遍历过了  while(hh<=tt)&#123;pair<int,int> t=q[hh++];    for(int i=0;i<4;i++)&#123;      int x=t.x+dx[i],y=t.y+dy[i];      if(check())//不满足的条件就跳过        continue;      q[++tt]=&#123;x,y&#125;;//新加入队列      st[x][y]=true;//标记访问过    &#125;  &#125;&#125;int main()&#123;&#125;</code></pre><h2 id="抓住那头牛"><a href="#抓住那头牛" class="headerlink" title="抓住那头牛"></a>抓住那头牛</h2><p><a href="https://www.acwing.com/problem/content/1102/">题目链接</a></p><pre class=" language-c++"><code class="language-c++">农夫知道一头牛的位置，想要抓住它。农夫和牛都位于数轴上，农夫起始位于点 N，牛位于点 K。农夫有两种移动方式：从 X 移动到 X−1 或 X+1，每次移动花费一分钟从 X 移动到 2∗X，每次移动花费一分钟假设牛没有意识到农夫的行动，站在原地不动。农夫最少要花多少时间才能抓住牛？输入格式共一行，包含两个整数N和K。输出格式输出一个整数，表示抓到牛所花费的最少时间。数据范围0≤N,K≤105输入样例：5 17输出样例：4</code></pre><pre class=" language-c++"><code class="language-c++">#include<iostream>#include<stdio.h>#include<cstring>using namespace std;const int N=2e5+10;int dist[N];int q[N];int n,k;int bfs()&#123;    memset(dist,-1,sizeof dist);    dist[n]=0;    int hh=0,tt=0;    q[0]=n;    while(hh<=tt)&#123;        int t=q[hh++];        if(t==k) return dist[t];        if(t+1<N&&dist[t+1]==-1)        &#123;            dist[t+1]=dist[t]+1;            q[++tt]=t+1;        &#125;        if(t-1>=0&&dist[t-1]==-1)        &#123;            dist[t-1]=dist[t]+1;            q[++tt]=t-1;        &#125;        if(t*2<N&&dist[t*2]==-1)        &#123;            dist[t*2]=dist[t]+1;            q[++tt]=2*t;;        &#125;    &#125;    return 0;&#125;int main()&#123;    cin>>n>>k; printf("%d\n",bfs());&#125;</code></pre><h2 id="走迷宫"><a href="#走迷宫" class="headerlink" title="走迷宫"></a>走迷宫</h2><p><a href="https://www.acwing.com/problem/content/846/">题目链接</a></p><pre class=" language-c++"><code class="language-c++">给定一个n*m的二维整数数组，用来表示一个迷宫，数组中只包含0或1，其中0表示可以走的路，1表示不可通过的墙壁。最初，有一个人位于左上角(1, 1)处，已知该人每次可以向上、下、左、右任意一个方向移动一个位置。请问，该人从左上角移动至右下角(n, m)处，至少需要移动多少次。数据保证(1, 1)处和(n, m)处的数字为0，且一定至少存在一条通路。输入格式第一行包含两个整数n和m。接下来n行，每行包含m个整数（0或1），表示完整的二维数组迷宫。输出格式输出一个整数，表示从左上角移动至右下角的最少移动次数。数据范围1≤n,m≤100输入样例：5 50 1 0 0 00 1 0 1 00 0 0 0 00 1 1 1 00 0 0 1 0输出样例：8</code></pre><pre class=" language-c++"><code class="language-c++">#include<cstdio>#include<iostream>#include<queue>using namespace std;int nx[4] = &#123;-1,1,0,0&#125;,ny[4] = &#123;0,0,-1,1&#125;,g[110][110];int step[110][110];pair<int,int> q[110*110];int bfs(int n,int m)&#123;    int hh=0,tt=0;    q[0]=&#123;0,0&#125;;    while(hh<=tt)&#123;        auto t = q[hh++];        int k = step[t.first][t.second];        if(t.first==n-1&&t.second==m-1) return k;        for(int i = 0;i < 4;i++)&#123;            int x = t.first + nx[i],y = t.second + ny[i];            if(step[x][y]==0&&g[x][y]==0&&x>=0&&y>=0&&x<n&&y<m)&#123;             q[++tt]=&#123;x,y&#125;;                step[x][y] = k+1;            &#125;        &#125;    &#125;&#125;int main()&#123;    int n,m;    cin>>n>>m;    for(int i = 0;i < n;i++)&#123;        for(int j = 0;j <m;j++)&#123;            cin>>g[i][j];        &#125;    &#125;    printf("%d\n",bfs(n,m));&#125;</code></pre><h2 id="迷宫问题"><a href="#迷宫问题" class="headerlink" title="迷宫问题"></a>迷宫问题</h2><p><a href="https://www.acwing.com/problem/content/1078/">题目链接</a></p><pre><code>给定一个 n×n 的二维数组，如下所示：int maze[5][5] = &amp;#123;0, 1, 0, 0, 0,0, 1, 0, 1, 0,0, 0, 0, 0, 0,0, 1, 1, 1, 0,0, 0, 0, 1, 0,&amp;#125;;它表示一个迷宫，其中的1表示墙壁，0表示可以走的路，只能横着走或竖着走，不能斜着走，要求编程序找出从左上角到右下角的最短路线。数据保证至少存在一条从左上角走到右下角的路径。输入格式第一行包含整数 n。接下来 n 行，每行包含 n 个整数 0 或 1，表示迷宫。输出格式输出从左上角到右下角的最短路线，如果答案不唯一，输出任意一条路径均可。按顺序，每行输出一个路径中经过的单元格的坐标，左上角坐标为 (0,0)，右下角坐标为 (n−1,n−1)。数据范围0≤n≤1000输入样例：50 1 0 0 00 1 0 1 00 0 0 0 00 1 1 1 00 0 0 1 0输出样例：0 01 02 02 12 22 32 43 44 4</code></pre><pre class=" language-c++"><code class="language-c++">#include<iostream>#include<stdio.h>using namespace std;const int N=1010,M=N*N;int a[N][N],n;#define x first#define y secondbool st[N][N];pair<int,int> q[M];pair<int,int> pre[N][N];int dx[4]=&#123;-1,1,0,0&#125;,dy[4]=&#123;0,0,-1,1&#125;;void bfs()&#123;    int hh=0,tt=0;    q[0]=&#123;n-1,n-1&#125;;    st[n-1][n-1]=true;    while(hh<=tt)&#123;        pair<int,int> t=q[hh++];        for(int i=0;i<4;i++)        &#123;            int c=t.x+dx[i],d=t.y+dy[i];            if(a[c][d]==1||c<0||c>=n||d>=n||d<0||st[c][d]==true)continue;            q[++tt]=&#123;c,d&#125;;            pre[c][d]=&#123;t.x,t.y&#125;;            st[c][d]=true;        &#125;    &#125;&#125;int main()&#123;    cin>>n;    for(int i=0;i<n;i++)    for(int j=0;j<n;j++)    cin>>a[i][j];    bfs();    pair<int,int> end=&#123;0,0&#125;;    printf("0 0\n");    while(end.x!=n-1||end.y!=n-1)&#123;        printf("%d %d\n",pre[end.x][end.y].x,pre[end.x][end.y].y);        int x=end.x,y=end.y;        end.x=pre[x][y].x,end.y=pre[x][y].y;    &#125;    return 0;&#125;</code></pre><h2 id="武士风度的牛"><a href="#武士风度的牛" class="headerlink" title="武士风度的牛"></a>武士风度的牛</h2><p><a href="https://www.acwing.com/problem/content/190/">题目链接</a></p><pre class=" language-c++"><code class="language-c++">农民John有很多牛，他想交易其中一头被Don称为The Knight的牛。这头牛有一个独一无二的超能力，在农场里像Knight一样地跳（就是我们熟悉的象棋中马的走法）。虽然这头神奇的牛不能跳到树上和石头上，但是它可以在牧场上随意跳，我们把牧场用一个x，y的坐标图来表示。这头神奇的牛像其它牛一样喜欢吃草，给你一张地图，上面标注了The Knight的开始位置，树、灌木、石头以及其它障碍的位置，除此之外还有一捆草。现在你的任务是，确定The Knight要想吃到草，至少需要跳多少次。The Knight的位置用’K’来标记，障碍的位置用’*’来标记，草的位置用’H’来标记。这里有一个地图的例子：             11 | . . . . . . . . . .             10 | . . . . * . . . . .              9 | . . . . . . . . . .              8 | . . . * . * . . . .              7 | . . . . . . . * . .              6 | . . * . . * . . . H              5 | * . . . . . . . . .              4 | . . . * . . . * . .              3 | . K . . . . . . . .              2 | . . . * . . . . . *              1 | . . * . . . . * . .              0 ----------------------                                    1                0 1 2 3 4 5 6 7 8 9 0The Knight 可以按照下图中的A,B,C,D…这条路径用5次跳到草的地方（有可能其它路线的长度也是5）：             11 | . . . . . . . . . .             10 | . . . . * . . . . .              9 | . . . . . . . . . .              8 | . . . * . * . . . .              7 | . . . . . . . * . .              6 | . . * . . * . . . F<              5 | * . B . . . . . . .              4 | . . . * C . . * E .              3 | .>A . . . . D . . .              2 | . . . * . . . . . *              1 | . . * . . . . * . .              0 ----------------------                                    1                0 1 2 3 4 5 6 7 8 9 0注意： 数据保证一定有解。输入格式第1行： 两个数，表示农场的列数C(C<=150)和行数R(R<=150)。第2..R+1行: 每行一个由C个字符组成的字符串，共同描绘出牧场地图。输出格式一个整数，表示跳跃的最小次数。输入样例：10 11..............*..................*.*...........*....*..*...H*............*...*...K...........*.....*..*....*..输出样例：5</code></pre><pre class=" language-c++"><code class="language-c++">#include<iostream>#include<algorithm>#include<stdio.h>#include<cstring>using namespace std;int n,m;#define x first#define y secondconst int N=200,M=N*N;char g[N][N];int map[N][N];pair<int,int> q[M],st,ed;int ans=0;int dx[8]=&#123;-1,-2,-2,-1,1,2,2,1&#125;,dy[8]=&#123;-2,-1,1,2,2,1,-1,-2&#125;;int bfs()&#123;    int hh=0,tt=0;    memset(map,-1,sizeof map);    q[0]=&#123;st.x,st.y&#125;;    map[st.x][st.y]=0;   while(hh<=tt)&#123;       pair<int,int> t=q[hh++];       int ans=map[t.x][t.y];       if(t.x==ed.x&&t.y==ed.y) return map[t.x][t.y];       for(int i =0;i<8;i++)&#123;          int c=t.x+dx[i],d=t.y+dy[i];           if(map[c][d]!=-1||c<0||c>=n||d<0||d>=m||g[c][d]=='*')continue;           q[++tt]=&#123;c,d&#125;;           map[c][d]=map[t.x][t.y]+1;       &#125;   &#125;    return 0;&#125;int main()&#123;    cin>>m>>n;    for(int i=0;i<n;i++)    for(int j=0;j<m;j++)&#123;    cin>>g[i][j];    if(g[i][j]=='K')    st.x=i,st.y=j;    if(g[i][j]=='H')    ed.x=i,ed.y=j;    &#125;   printf("%d\n",bfs());&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithmBFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>prim</title>
      <link href="/2020/081126197.html"/>
      <url>/2020/081126197.html</url>
      
        <content type="html"><![CDATA[<h1 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h1><p><a href="https://www.acwing.com/problem/content/860/">模板题木链接</a></p><h2 id="Prim算法概括"><a href="#Prim算法概括" class="headerlink" title="Prim算法概括"></a>Prim算法概括</h2><blockquote><p>文字来源 蓝书 【算法竞赛进阶指南】</p><p>Prim算法总是维护最小生成树的一部分</p><p>适用于稠密图，尤其是完全图的最小生成树的求解</p><p>最初，只确定1号节点属于最小生成树</p><p>任意时间，设已经确定属于最小生成树节点的集合为T<br>                                         省余节点的集合为S</p><p>Prim找到 min x∈T，y∈S {z}</p><p>即：两个端点分别属于 S,T的权值的最小边，</p><p>把x从集合S 中删除，加入集合T中，并把 z 加入到答案中</p><p>维护数组d[], 若x∈S，d[x]表示节点x和节点T中的节点之间的权值的最小边。若x属于T，d[x]表示x被加入T是选出的最小边的权值</p></blockquote><h2 id="prim算法流程"><a href="#prim算法流程" class="headerlink" title="prim算法流程"></a>prim算法流程</h2><blockquote><p>【1】、先把数组d 赋值为正无穷</p><p>【2】、遍历n次 每次找到结合S中距离最近的点复制给 t</p><p>【3】、v[t]=true t边用过了</p><p>【4】、用 t 更新其他点到集合的距离</p></blockquote><h2 id="prim朴素算法代码"><a href="#prim朴素算法代码" class="headerlink" title="prim朴素算法代码"></a>prim朴素算法代码</h2><pre class=" language-c++"><code class="language-c++">using namespace std;const int N=3010;int a[N][N],d[N],n,m,ans;bool v[N];void prim()&#123;    memset(d,0x3f,sizeof d);    memset(v,0,sizeof v);    d[1]=0; //第一个点可以默认在T集合中    for(int i=1;i<n;i++)&#123; //遍历n次        int x=0;        for(int j=1;j<=n;j++)        if(!v[j]&&(x==0||d[j]<d[x]))x=j; //找到最小权值            v[x]=1; //x这个最小权值边用过了            for(int y=1;y<=n;y++) //更新点到集合T的距离            if(!v[y])d[y]=min(d[y],a[x][y]);    &#125;&#125;int main()&#123;    cin>>n>>m;    memset(a,0x3f,sizeof a); //用邻接矩阵存储 初始化都是不通的    for(int i=1;i<=n;i++) a[i][i]=0; //自己到自己为0    for(int i=1;i<=m;i++)    &#123; int x,y,z;        cin>>x>>y>>z;        a[x][y]=a[y][x]=min(a[x][y],z); //无向图 所以 x->y y->x都要存    &#125;    prim();    for(int i=2;i<=n;i++)ans+=d[i]; //d就是prim以后每次加如集合T的最小权值     if(ans>4990000) //(500-1)*10000     printf("impossible\n");    else    printf("%d\n",ans);&#125;</code></pre><blockquote><p>等待更新</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
