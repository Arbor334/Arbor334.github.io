<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>背包问题</title>
      <link href="/2020/090660354.html"/>
      <url>/2020/090660354.html</url>
      
        <content type="html"><![CDATA[<h1>背包问题</h1><h2 id="01背包">01背包</h2><p><a href="https://www.acwing.com/problem/content/description/2/" target="_blank" rel="noopener">联系题目链接</a></p><blockquote><p>什么是01背包问题呢？</p><blockquote><p>给定n件物品 还有一个容量为V的背包，</p><p>再给出  n件物品的体积和价值 每件物品只能选一次</p><p>求出背包的最大价值</p></blockquote></blockquote><ul><li>二维做法</li></ul><pre class=" language-language-cpp"><code class="language-language-cpp">/*用f[i][j]表示前i件物品恰放入容量为j的背包可以获得的最大价值 与f[i][j]状态相关的可以分为两类：【1】、f[i-1][j]  第i件物品没有选，就将前 i-1件物品放入容量为j的背包中【2】、f[i-1][j-v[i]]+w[i]  选了，就放入容量为 j-v[i]的背包中       这种二维数组 空间，时间复杂度都是 0(n*v)*/#include<iostream>#include<stdio.h>#include<algorithm>using namespace std;const int N=2110;int n,m,v[N],w[N],dp[N][N];int main(){    cin>>n>>m;    for(int i=1;i<=n;i++)cin>>v[i]>>w[i];    dp[0][0]=0; //初始化一下    for(int i=1;i<=n;i++)    for(int j=1;j<=m;j++)    {        dp[i][j]=dp[i-1][j]; // 不选择        if(j>=v[i]) // 有地方可以放下这个物品       dp[i][j]=max(dp[i-1][j],dp[i-1][j-v[i]]+w[i]); //取最大值    }        int ans=0;    for(int i=1;i<=m;i++)ans=max(ans,dp[n][i]);//最大值并不是f[n][m] 所以要取f[n][0]~f[n][m]的最大值    cout<<ans;    }</code></pre><ul><li>一维优化</li></ul><pre class=" language-language-cpp"><code class="language-language-cpp">/*此优化 让空间复杂度降为 O(V)*/#include<iostream>#include<stdio.h>using namespace std;const int N=1900;int v[N],w[N],n,m,dp[N];int main(){    cin>>n>>m;    for(int i=1;i<=n;i++)cin>>v[i]>>w[i];   dp[0]=0;   for(int i=1;i<=n;i++)   for(int j=m;j>=v[i];j--)//倒叙   dp[j]=max(dp[j],dp[j-v[i]]+w[i]);//这里用到的实际是dp[i] 而不是dp[i-1]的状态 为了保证dp[i]已经运行过了 所以 j是倒序   cout<<dp[m];  // 这里的dp[m]是容量小于等于m的 最大价值并不是恰好是容量是m的最大价值如果恰好是m的话，初始化的时候，除了dp[0]=0，其他的初始化为-INF  这样最后的需要遍历一遍 找到最大值 这个最大值才是恰好为m时的}</code></pre><h2 id="完全背包">完全背包</h2><p><a href="https://www.acwing.com/problem/content/description/3/" target="_blank" rel="noopener">题目链接</a></p><blockquote><p>什么是完全背包问题?</p><blockquote><p>n件物品和一个容量为V的背包，每件物品可以多次使用。</p><p>第i件物品的容量是C[I],价值是w[i],</p><p>求哪些物品装入背包所占容量不超过V，且价值总和最大。</p></blockquote></blockquote><pre class=" language-language-cpp"><code class="language-language-cpp">/*与01背包相比，我们这里需要考虑不是选不选择第i个物品，而是 选择第i个物品多少件和其他的物品的价值总和才能达到最大值。在01背包的时候，For(int  i=1;i<=n;i++)  f[i][j]=f[i-1][j];//不选       if(j>=v[i])//选择   f[i][j]=max(f[i-1][j],f[i-1][j-v[i]]+c[i]); //我们这里用到的是f[i-1][j-v[i]] 并不包含第i个物品，因为我们需要的是还没有选择第i件物品的时候的状态For(int i=1;i<=n;i++)For(int j=v[i];j<=m;j++) F[j]=max(f[j],f[j-v[i]]+w[i]);//这里我们用到了第i个物品，里面可能包含了若干个第i个物品我们需要这样包含第i件物品的状态*/#include<iostream>#include<stdio.h>using namespace std;const int N=10010;int v[N],c[N],dp[N],n,V;int main(){    cin>>n>>V;    for(int i=1;i<=n;i++)cin>>v[i]>>c[i];    for(int i=1;i<=n;i++)    for(int j=v[i];j<=V;j++) //枚举每件物品的体积，开始1个的时候就就撑不下 就不必考虑    dp[j]=max(dp[j],dp[j-v[i]]+c[i]);    int ans=-1;    for(int i=1;i<=V;i++)ans=max(ans,dp[i]);    cout<<ans<<endl;}</code></pre><h2 id="多组背包问题">多组背包问题</h2><p><a href="https://www.acwing.com/problem/content/4/" target="_blank" rel="noopener">题目链接</a></p><blockquote><p>什么是多组背包问题</p><blockquote><p>n件物品，一个容量为v的背包，第i件物品最多有n[i]件可用。每件体积是v[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。</p></blockquote></blockquote><pre class=" language-language-cpp"><code class="language-language-cpp">#include<iostream>#include<stdio.h>#include<algorithm>using namespace std;const int N=10010;int v,w,s,n,V,dp[N];int main(){    cin>>n>>V;    for(int i=1;i<=n;i++){        cin>>v>>w>>s;        for(int j=V;j>=0;j--)            for(int k=1;k<=s&&k*v<=j;k++) //只需要在01背包中加入一重循环即可            dp[j]=max(dp[j],dp[j-k*v]+w*k);    }    cout<<dp[V];}</code></pre><blockquote><p>数据范围大的时候用 二进制优化</p><p>时间复杂度是  O(N×log(s)×V)</p></blockquote><pre class=" language-language-cpp"><code class="language-language-cpp">/*  多组背包问题的二进制优化方法   就是将 s件物品分成 1 2 4 8... 这样的一组是 1件 一组是2 件   再看成是01背包的问题*/#include<iostream>#include<stdio.h>#include<vector>using namespace std;struct node{    int v,w;};vector<node>goods;const int N=2010;int n,m,v,w,s,f[N];int main(){    cin>>n>>m;    for(int i=1;i<=n;i++){        cin>>v>>w>>s;            for(int k=1;k<=s;k*=2){ //这就是分成 1 2 4 8 这样的组                s-=k;                goods.push_back({k*v,k*w});        }        if(s) goods.push_back({s*v,s*w});    }    for(auto good:goods){   //在像01背包一样        for(int j=m;j>=good.v;j--){            f[j]=max(f[j],f[j-good.v]+good.w);        }    }    cout<<f[m]<<endl;}</code></pre><blockquote><p>还有一种优化是单调队列 优化 不过没有理解  先鸽一段时间</p></blockquote><h2 id="混合背包问题">混合背包问题</h2><p><a href="https://www.acwing.com/problem/content/description/7/" target="_blank" rel="noopener">题目链接</a></p><blockquote><p>什么是混合背包问题？</p><blockquote><p>有 N 种物品和一个容量是 V 的背包。</p><p>物品一共有三类：</p><p>第一类物品只能用1次（01背包）；</p><p>第二类物品可以用无限次（完全背包）；</p><p>第三类物品最多只能用 s[i]次（多重背包）；</p><p>每种体积是 v[i]，价值是 w[i]</p></blockquote><p>分析</p><blockquote><p>多重背包问题我们可以用上面的二进制优化的方法 分成多份  变成 01背包问题</p><p>​     这样就只有 完全背包问题 和 01背包 这两种情况了</p><p>​     01背包问题在一维中  j=m;j&lt;=v;j--        0大到小</p><p>​     完全背包问题 在一维中  j=v;j&lt;=m;j++    完小到大</p></blockquote></blockquote><pre class=" language-language-cpp"><code class="language-language-cpp">#include<iostream>#include<stdio.h>#include<vector>using namespace std;const int N=10010;int v,n,m,w,s,op,dp[N];struct node{    int v,w,op;};vector<node>goods;int main(){    cin>>n>>m;    for(int i=1;i<=n;i++){        cin>>v>>w>>op;        if(op==0)    goods.push_back({v,w,0});  //完全背包问题        else if(op==-1) goods.push_back({v,w,-1}); //01 背包        else {   //多重背包问题化为01背包问题            for(int j=1;j<=op;j*=2){                op-=j;                goods.push_back({v*j,w*j,-1});            }            if(op>0) goods.push_back({v*op,w*op,-1});        }    }    for(auto good:goods){        if(good.op==0) //完全背包问题            for(int j=good.v;j<=m;j++) dp[j]=max(dp[j],dp[j-good.v]+good.w);         else     //01背包问题          for(int j=m;j>=good.v;j--) dp[j]=max(dp[j],dp[j-good.v]+good.w);    }    cout<<dp[m]<<endl;}</code></pre><h2 id="二维费用的背包问题">二维费用的背包问题</h2><blockquote><p>什么是二维费用的背包问题？</p><blockquote><p>有 N 件物品和一个容量是 V的背包，背包能承受的最大重量是 M。</p><p>每件物品只能用一次。体积是 vi，重量是 mi，价值是 wi。</p><p>求解将哪些物品装入背包，可使物品总体积不超过背包容量，总重量不超过背包可承受的最大重量，且价值总和最大。<br>输出最大价值</p></blockquote><p>分析</p><blockquote><p>f[i,j,k] 从前i个物品中 选择总i体积不超过j  总重量不超过k的集合</p><p>f[i,j,k]=max(f[i-1,j,k],f[i-1,j-v[i],k-w[i]]);</p><p>可以只使用二维的数组：</p><p>当每件物品只可以取一次时变量V和M采用顺序的循环，</p><p>当物品有如完全背包问题时采用逆序的循环。</p><p>当物品有如多重背包问题时拆分物品。</p></blockquote></blockquote><pre class=" language-language-cpp"><code class="language-language-cpp">#include<iostream>#include<stdio.h>using namespace std;const int N=1010;int T,V,M,m,v,w;int f[N][N];int main(){    cin>>T>>V>>M;//输入物品件数 最大体积 最大重量    for(int i=1;i<=T;i++){        cin>>v>>m>>w; //输入体积 重量 价值        for(int j=V;j>=v;j--)  //            for(int k=M;k>=m;k--)                f[j][k]=max(f[j][k],f[j-v][k-m]+w);    }    cout<<f[V][M]<<endl;}</code></pre><h2 id="分组背包问题">分组背包问题</h2><blockquote><p>什么是分组背包问题？</p><blockquote><p>有 N 组物品和一个容量是 V的背包。</p><p>每组物品有若干个，同一组内的物品最多只能选一个。<br>每件物品的体积是 vij，价值是 wij，其中 i是组号，j是组内编号。</p><p>求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。</p><p>输出最大价值。</p></blockquote><p>分析</p><blockquote><p>F[I,J]含义是  只从前i组中选，且体积不大于J的方案集合</p><p>这一组不选 那么F[I,J]=F[I-1,J]</p><p>这一组选了第k个物品 就是 F[I,J]=F[I-1,J-Vik]+Wik</p></blockquote></blockquote><pre class=" language-language-cpp"><code class="language-language-cpp">#include<iostream>#include<stdio.h>using namespace std;const int N=101;int f[N],v[N][N],w[N][N],s[N];int n,m;int main(){   cin>>n>>m; //输入物品组数和背包容量   for(int i=1;i<=n;i++)   {  cin>>s[i]; //记录下来这个物品组有多少个物品      for(int j=1;j<=s[i];j++)         cin>>v[i][j]>>w[i][j];   }   int res=0;   for(int i=1;i<=n;i++)   for(int j=m;j>=0;j--) //枚举体积   for(int k=1;k<=s[i];k++) //，枚举物品数   {    //只有背包体积大于物品体积时       if(j>=v[i][k]) f[j]=max(f[j],f[j-v[i][k]]+w[i][k]);       res=max(res,f[j]);   }   cout<<res<<endl;}</code></pre><h2 id="有依赖的背包问题">有依赖的背包问题</h2><p><a href="https://www.acwing.com/problem/content/description/10/" target="_blank" rel="noopener">题目链接</a></p><pre class=" language-language-cpp"><code class="language-language-cpp">#include<iostream>#include<cstring>#include<algorithm>using namespace std;const int N = 110;int n,m;int h[N],e[N],ne[N],idx;int v[N],w[N],f[N][N];void add(int a,int b){    e[idx] = b,ne[idx] = h[a],h[a] = idx++;}void dfs(int u){    for(int i = h[u];i!=-1;i = ne[i]){//对当前结点的边进行遍历        int son = e[i];//e数组的值是当前边的终点，即儿子结点        dfs(son);        for(int j = m-v[u];j>=0;j--){        //遍历背包的容积，因为我们是要遍历其子节点，所以当前节点我们是默认选择的。        //这个时候当前结点我们看成是分组背包中的一个组，子节点的每一种选择我们都看作是组内一种物品，所以是从大到小遍历。        //我们每一次都默认选择当前结点，因为到最后根节点是必选的。            for(int k = 0;k<=j;k++){//去遍历子节点的组合                f[u][j] = max(f[u][j],f[u][j-k]+f[son][k]);            }        }    }    //加上刚刚默认选择的父节点价值    for(int i = m;i>=v[u];i--){        f[u][i] = f[u][i-v[u]]+w[u];    }    //因为我们是从叶子结点开始往上做，所以如果背包容积不如当前物品的体积大，那就不能选择当前结点及其子节点，因此赋值为零    for(int i = 0;i<v[u];i++){        f[u][i] = 0;    }}int main(){    memset(h,-1,sizeof h);    cin>>n>>m;    int root;    for(int i = 1;i<=n;i++){        int p;        cin>>v[i]>>w[i]>>p;        if(p==-1){            root = i;        }else{            add(p,i);//如果不是根节点就加入邻接表,其中p是该节点的父节点，i是当前是第几个节点        }    }    dfs(root);    cout<<f[root][m]<<endl;    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 背包问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 背包问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>疯狂A题训训练搜索篇</title>
      <link href="/2020/090164192.html"/>
      <url>/2020/090164192.html</url>
      
        <content type="html"><![CDATA[<h1>疯狂A题训练——搜索篇</h1><h2 id="P1443-马的遍历">P1443 马的遍历</h2><blockquote><p>更新步数的时候，是在跳到这一步的那步的基础上  步数+1</p></blockquote><pre class=" language-language-cpp"><code class="language-language-cpp">const int N=410;int g[N][N];bool v[N][N];int n,m,sx,sy;queue<pair<int,int> >q;int dy[10]={-1,-2,-2,-1,1,2,2,1};int dx[10]={-2,-1,1,2,2,1,-1,-2};int main(){    scanf("%d%d%d%d",&n,&m,&sx,&sy); memset(g,-1,sizeof g);   memset(v,0,sizeof v);   g[sx][sy]=0,v[sx][sy]=true;   q.push({sx,sy});   while(q.size()){       int x=q.front().first,y=q.front().second;q.pop();       for(int i=0;i<8;i++){           int ex=x+dx[i],ey=y+dy[i];           if(v[ex][ey]||ex<1||ex>n||ey<1||ey>m)continue;               g[ex][ey]=g[x][y]+1; // g[ex][ey]这个点 是由 g[x][y]这个点跳过来的 在g[x][y]的基础上+1               v[ex][ey]=1;               q.push({ex,ey});       }   }    for(int i=1;i<=n;i++){    for(int j=1;j<=m;j++)    printf("%-5d",g[i][j]);        printf("\n");    }}</code></pre><h2 id="P1747-好奇怪的游戏">P1747 好奇怪的游戏</h2><blockquote><p>我们反过来想，就是从（1,1）点到（x,y）点 做两遍宽搜</p><p>无论是“日”还是“田” 他们都是由“口”组成</p><p>画个图就是 长为4 宽为4 中点是 棋子</p><p>找到 “日” 和“田” 的坐标</p></blockquote><pre class=" language-language-cpp"><code class="language-language-cpp">#include<iostream>#include<stdio.h>#include<algorithm>#include<map>#include<cstring>#include<queue>using namespace std;const int N=30;queue<pair<int,int> >q;bool v[N][N];int ex,ey;int a[N][N];int dx[12]={-1,-2,-2,-2,-2,-1,1,2,2,2,2,1}; //日和 田的坐标混合在一起int dy[12]={-2,-2,-1,1,2,2,2,2,1,-1,-2,-2};void bfs(int sx,int sy){    while(q.size())q.pop();    memset(a,0,sizeof a);    memset(v,0,sizeof v);    a[sx][sy]=0,v[sx][sy]=1;    q.push({sx,sy});    while(q.size()){        int x=q.front().first,y=q.front().second;q.pop();        for(int i=0;i<12;i++){            int nx=x+dx[i],ny=y+dy[i];            if(v[nx][ny]||nx<1||nx>50||ny<1||ny>50)continue;            v[nx][ny]=1;            a[nx][ny]=a[x][y]+1;            if(nx==ex&&ny==ey)return ;//搜到了直接返回            q.push({nx,ny});        }    }}int main(){    for(int i=1;i<=2;i++){    scanf("%d%d",&ex,&ey);    bfs(1,1);    printf("%d\n",a[ex][ey]);    }}</code></pre><h2 id="P1746-离开中山路">P1746 离开中山路</h2><blockquote><p>emmmm  纯模板</p></blockquote><pre class=" language-language-cpp"><code class="language-language-cpp">#include<iostream>#include<stdio.h>#include<algorithm>#include<queue>#include<cstring>#include<map>using namespace std;int dx[4]={1,0,-1,0};int dy[4]={0,1,0,-1};const int N=1020;int g[N][N];char a[N][N];bool v[N][N];int sx,sy,ex,ey,n;queue<pair<int,int> >q;void bfs(){    memset(g,0,sizeof g);    memset(v,0,sizeof v);    g[sx][sy]=0,v[sx][sy]=1;    q.push({sx,sy});    while(q.size()){        int x=q.front().first,y=q.front().second;q.pop();        for(int i=0;i<4;i++){            int nx=x+dx[i],ny=y+dy[i];            if(nx<1||ny<1||nx>n||ny>n||v[nx][ny]||a[nx][ny]=='1')continue;            g[nx][ny]=g[x][y]+1;            v[nx][ny]=1;            if(nx==ex&&ny==ey)return;            q.push({nx,ny});        }    }}int main(){    scanf("%d",&n);    for(int i=1;i<=n;i++)    for(int j=1;j<=n;j++)   //    cin>>a[i][j];    scanf("%d %d %d %d",&sx,&sy,&ex,&ey);    bfs();    printf("%d\n",g[ex][ey]);}</code></pre><h2 id="P2298-Mzc和男家丁的游戏">P2298 Mzc和男家丁的游戏</h2><blockquote><p>如何用最短的距离从起点走到终点</p></blockquote><pre class=" language-language-cpp"><code class="language-language-cpp">#include<iostream>#include<stdio.h>#include<algorithm>#include<cstring>#include<queue>#include<map>using namespace std;const int N=4020;char g[N][N];int a[N][N];int dx[4]={0,1,0,-1};int dy[4]={1,0,-1,0};;bool v[N][N];int sx,sy,ex,ey,n,m;queue<pair<int,int> >q;void bfs(){    memset(a,0x3f,sizeof(a));    memset(v,0,sizeof v);    v[sx][sy]=1,a[sx][sy]=0;    q.push({sx,sy});    while(q.size()){        int x=q.front().first,y=q.front().second;        q.pop();        if(x==ex&&y==ey)return ;// 如果已经到了终点 直接退出        for(int i=0;i<4;i++){            int nx=x+dx[i],ny=y+dy[i];            if(nx<1||ny<1||nx>n||ny>m||g[nx][ny]=='#'||v[nx][ny])continue;            v[nx][ny]=1;            a[nx][ny]=a[x][y]+1;//在上一次的基础上 在加一步            if(nx==ex&&ny==ey)return ;            q.push({nx,ny});        }    }}int main(){    scanf("%d%d",&n,&m);    for(int i=1;i<=n;i++)    for(int j=1;j<=m;j++){// 知道终点和起点       //cin>>g[i][j];        if(g[i][j]=='m')        sx=i,sy=j;        if(g[i][j]=='d')        ex=i,ey=j;    }    bfs();    if(a[ex][ey]>0x3f3f3f3f/2)    puts("No Way!");    else    printf("%d\n",a[ex][ey]);}</code></pre><h2 id="P1332-血色先锋队">P1332 血色先锋队</h2><blockquote><p>同时向外扩张的一个例题把</p></blockquote><pre class=" language-language-c"><code class="language-language-c">#include<iostream>#include<stdio.h>#include<algorithm>#include<map>#include<cstring>#include<queue>using namespace std;const int N=1000;int g[N][N];bool v[N][N];int dx[4]={0,1,0,-1};int dy[4]={1,0,-1,0};int n,m,a,b;queue<pair<int,int> >q;pair<int,int>a1[100100],b1[100100];void bfs(){    memset(v,0,sizeof v);    memset(g,-1,sizeof g);    for(int i=1;i<=a;i++){ //把起点都加入到 队列中 每次q.pop()之后，下一次就是用下一个起点，进而产生同步        q.push({a1[i].first,a1[i].second});        v[a1[i].first][a1[i].second]=1;        g[a1[i].first][a1[i].second]=0;    }    while(q.size()){        int x=q.front().first,y=q.front().second;q.pop();        for(int i=0;i<4;i++){            int nx=x+dx[i],ny=y+dy[i];            if(nx<1||ny<1||nx>n||ny>m||v[nx][ny])continue;            g[nx][ny]=g[x][y]+1;            v[nx][ny]=1;            q.push({nx,ny});        }    }}int main(){scanf("%d%d%d%d",&n,&m,&a,&b);for(int i=1;i<=a;i++)  {int x,y;      //cin>>x>>y;      a1[i]=make_pair(x,y);  }   for(int i=1;i<=b;i++){       int x,y;       // cin>>x>>y;       b1[i]=make_pair(x,y);   }   bfs();   for(int i=1;i<=b;i++){       printf("%d\n",g[b1[i].first][b1[i].second]);   }}</code></pre><h2 id="P1451-求细胞数量">P1451 求细胞数量</h2><blockquote></blockquote><pre class=" language-language-c"><code class="language-language-c">#include<iostream>#include<stdio.h>#include<algorithm>#include<map>#include<cstring>#include<queue>using namespace std;const int N=1000;int ans,a[N][N];bool v[N][N];int dx[4]={0,1,0,-1};int dy[4]={1,0,-1,0};int n,m;queue<pair<int,int> >q;void bfs(int sx,int sy){    while(!q.empty())q.pop();    ans++; //每bfs一次  说明多了一个细胞    v[sx][sy]=1;    q.push({sx,sy});    while(q.size()){        int x=q.front().first,y=q.front().second;q.pop();        for(int i=0;i<4;i++){            int nx=x+dx[i],ny=y+dy[i];            if(nx<1||ny<1||nx>n||ny>m||v[nx][ny]||a[nx][ny]==0)continue;            v[nx][ny]=1;            q.push({nx,ny});        }    }}int main(){    memset(v,0,sizeof v);scanf("%d%d",&n,&m);for(int i=1;i<=n;i++)  for(int j=1;j<=m;j++){     char ch;     // cin>>ch;     a[i][j]=ch-'0';  }   for(int i=1;i<=n;i++)   for(int j=1;j<=m;j++)   if(!v[i][j]&&a[i][j]!=0) bfs(i,j); //没有遍历过的 再去bfs  printf("%d\n",ans);}</code></pre><h2 id="P1141-01迷宫">P1141 01迷宫</h2><blockquote><p>这道题的范围很大 所以要做一点优化</p></blockquote><pre class=" language-language-c"><code class="language-language-c">#include<iostream>#include<stdio.h>#include<cstring>#include<queue>#include<map>using namespace std;const int N=1010;struct node{    int x,y,w;};int a[N][N],sx,sy,ans,n,m,block[N][N];//block 存答案int dx[4]={0,1,0,-1};int dy[4]={1,0,-1,0};bool v[N][N];void bfs(){ //便利的同时 把连通块的值都更新了    vector<node>pos;  //存遍历过的点 也就是连通块   queue<node>q;    node now,nx;    q.push({sx,sy});    v[sx][sy]=1;    ans=1;    while(q.size()){     now=q.front();q.pop();        pos.push_back(now);// 这个now 就是连通块中的一部分        for(int i=0;i<4;i++){            nx.x=now.x+dx[i],nx.y=dy[i]+now.y;            if(nx.x<1||nx.y<1||nx.x>n||nx.y>n||v[nx.x][nx.y]||a[now.x][now.y]==a[nx.x][nx.y])continue;            ans++;            v[nx.x][nx.y]=1;            q.push(nx);        }    }    for(auto v:pos) block[v.x][v.y]=ans;//遍历过的点就是一个连通块，一个连通块的值是一样的}int main(){    scanf("%d%d",&n,&m);    for(int i=1;i<=n;i++)    for(int j=1;j<=n;j++)    {        scanf("%1d",&a[i][j]);    }    memset(v,0,sizeof(v));    while(m--){        scanf("%d%d",&sx,&sy);       if(!block[sx][sy]) bfs(); //这个点没有遍历过才去遍历，        printf("%d\n",block[sx][sy]);    }}</code></pre><h2 id="P1162-填涂颜色">P1162 填涂颜色</h2><blockquote><p>在做这道题之前  建议先做<a href="https://www.luogu.com.cn/problem/P1506" target="_blank" rel="noopener">拯救oibh总部</a></p><p>他们几乎是一样的模板</p><p>这道题是 先把</p></blockquote><pre class=" language-language-c"><code class="language-language-c">#include<iostream>#include<stdio.h>#include<algorithm>using namespace std;const int N=40;int g[N][N],n;int dx[4]={0,1,0,-1};int dy[4]={1,0,-1,0};void dfs(int x,int y){    if(x<0||x>n+1||y<0||y>n+1||g[x][y])//这里为啥是 > n+1呢  就是因为dfs会自己遍历 把 由1组成的这一圈外面的0都变成 2  输出的时候有所体现    return ;    g[x][y]=2;    for(int i=0;i<4;i++)    dfs(x+dx[i],y+dy[i]);}int main(){    scanf("%d",&n);    for(int i=1;i<=n;i++)    for(int j=1;j<=n;j++)    {    scanf("%d",&g[i][j]);    }    dfs(0,0);//从外一层开始  相当于 在属于的g[i][j]周围 又围了一层    for(int i=1;i<=n;i++){    for(int j=1;j<=n;j++)      printf("%d ",2-g[i][j]);        puts("");    }}</code></pre><h2 id="P1683-入门">P1683 入门</h2><blockquote><p>很简单的深搜题  就是输入的时候 最好是使用cin</p><p>这个问题 我试了 scanf(&quot;%c&quot;) scanf(&quot;%1d&quot;) 还就是cin 好使</p></blockquote><pre class=" language-language-cpp"><code class="language-language-cpp">#include<iostream>#include<stdio.h>#include<cstring>using namespace std;const int N=40;char g[N][N];int n,m,sx,sy,ans=0;bool v[N][N];int dx[4]={0,1,0,-1};int dy[4]={1,0,-1,0};void dfs(int x,int y){    if(x<1||x>m||y<1||y>n||v[x][y]||g[x][y]=='#')return ;    v[x][y]=1;ans++;    for(int i=0;i<4;i++)    dfs(x+dx[i],y+dy[i]);}int main(){    char e;    scanf("%d%d",&n,&m);    for(int i=1;i<=m;i++)    for(int j=1;j<=n;j++){      // cin>>e;         if(e!='#')         g[i][j]=e;         else g[i][j]='#';         if(e=='@')         sx=i,sy=j;    }    // for(int i=1;i<=m;i++){    // for(int j=1;j<=n;j++)    //  printf("%c ",g[i][j]);    //     printf("\n");    // }    memset(v,0,sizeof v);    dfs(sx,sy);    // cout<<endl;    //  for(int i=1;i<=m;i++){    // for(int j=1;j<=n;j++)    //  printf("%c ",g[i][j]);    //     printf("\n");    // }    printf("%d\n",ans);}</code></pre><h2 id="P5198-USACO19JAN-Icy-Perimeter-S">P5198 [USACO19JAN]Icy Perimeter S</h2><blockquote><p>这种求<code>周长</code>题以前没有做过</p><p>解释周长：</p><p>​     就是<code>#</code>外面围的一圈 <code>.</code>的个数，</p></blockquote><pre class=" language-language-cpp"><code class="language-language-cpp">#include<iostream>#include<queue>#include<stdio.h>#include<algorithm>#include<cstring>using namespace std;const int N=1010;int g[N][N],n,ansa,ansl;//面积  长度bool v[N][N];struct node{    int x,y;}a,b,c,d;int dx[4]={0,1,0,-1};int dy[4]={1,0,-1,0};void bfs(int sx,int sy){  queue<node>q;  int area=1,len=0;  a.x=sx,a.y=sy;  for(int i=0;i<4;i++){ //搜索起点的周围的`.` 就是起点这一部分周长      c.x=a.x+dx[i];      c.y=a.y+dy[i];      if(g[c.x][c.y]==-1)      len++;  }  v[sx][sy]=1;  q.push(a);   //加入起点  while(!q.empty()){      int x=q.front().x,y=q.front().y;q.pop();      for(int i=0;i<4;i++){  //搜索可以做的地点          int nx=x+dx[i],ny=y+dy[i];          if(nx<1||nx>n||ny<1||ny>n||v[nx][ny]||g[nx][ny]==-1)continue;          area++;          v[nx][ny]=1;          q.push({nx,ny});          for(int i=0;i<4;i++){  //在搜索这个点周围的周长              int nnx=nx+dx[i],nny=ny+dy[i];              if(g[nnx][nny]==-1)              len++;          }      }      if(ansa<area)//更新面积和长度      {          ansa=area;          ansl=len;      }      else if(ansa==area){          if(ansl>len)          ansl=len;      }  }  return ;}int main(){    memset(g,-1,sizeof(g));    memset(v,0,sizeof v);    scanf("%d",&n);    char ch;    for(int i=1;i<=n;i++)       for(int j=1;j<=n;j++)        {         //   cin>>ch;            if(ch=='#')            g[i][j]=1;        }    for(int i=1;i<=n;i++)       for(int j=1;j<=n;j++){            if(g[i][j]==1&&v[i][j]==0)            bfs(i,j);        }        printf("%d %d\n",ansa,ansl);    }</code></pre><h2 id="P1126-机器人搬重物">P1126 机器人搬重物</h2><blockquote><p>这道题的细节比较多</p></blockquote><pre class=" language-language-cpp"><code class="language-language-cpp">#include<iostream>#include<stdio.h>#include<queue>#include<algorithm>using namespace std;const int N=60;struct node{    int x,y;    int dir;    int cnt;};queue<node>q;bool v[N][N][4];bool g[N][N];int dx[4]={0,1,0,-1};int dy[4]={1,0,-1,0};int n,m,sx,sy,ex,ey,sd;char sdir;//其实时候的方向int main(){    cin>>n>>m;    for(int i=1;i<=n;i++)    for(int j=1;j<=m;j++)    {        cin>>g[i][j];//认为输入的是格子的右下        if(g[i][j]){            g[i-1][j-1]=1;//左上            g[i-1][j]=1;//左下            g[i][j-1]=1;//右上        }    }    cin>>sx>>sy>>ex>>ey>>sdir;    if(sdir=='E') sd=0;// 东    else if(sdir=='S') sd=1;//南    else if(sdir=='W')sd=2;//西    else sd=3; //北    if(sx<1||sx>=n||sy<1||sy>=m||g[sx][sy]){printf("-1\n");return 0;}//不符合就特判一下    node temp;   //先把最开始的数据都加进去    temp.x=sx,temp.y=sy,temp.dir=sd,temp.cnt=0;    v[sx][sy][sd]=1;    q.push(temp);    while(q.size()){        temp=q.front();        q.pop();        int nx=temp.x,ny=temp.y;        if(nx==ex&&ny==ey){printf("%d\n",temp.cnt);return 0;}        for(int i=1;i<4;i++){ //这里是 走1步和三步都是时间加1             nx+=dx[temp.dir],ny+=dy[temp.dir];            if(nx<1||nx>=n||ny<1||ny>=m||g[nx][ny])break;//不符合题意就退出走方向            if(!v[nx][ny][temp.dir]){            v[nx][ny][temp.dir]=1;            node now;            now.x=nx,now.y=ny,now.dir=temp.dir,now.cnt=temp.cnt+1;           // printf("%d %d %d %d cnt:%d\n",temp.x,temp.y,nx,ny,temp.cnt);            q.push(now);            }        }      //转向      node now;      now.x=temp.x,now.y=temp.y,now.cnt=temp.cnt+1;//因为dx dy是按照东 南 西 北的顺序    now.dir=temp.dir-1; //左转    if(now.dir==-1)now.dir=3; //转过头了 东向北 判断一下    if(!v[now.x][now.y][now.dir]){v[now.x][now.y][now.dir]=1;q.push(now);};    now.dir=temp.dir+1;//右转    if(now.dir==4)now.dir=0;//转过头了 北向东 判断一下     if(!v[now.x][now.y][now.dir]){v[now.x][now.y][now.dir]=1;q.push(now);};    }    printf("-1\n");    return 0;}</code></pre><h2 id="P1019-单词接龙">P1019 单词接龙</h2><blockquote></blockquote><pre class=" language-language-cpp"><code class="language-language-cpp">#include<iostream>#include<stdio.h>#include<algorithm>#include<vector>#include<string>using namespace std;const int N=40;string s[N],sd;vector<string>v;int g[N][N],used[N],n;void dfs(string str,int last){    used[last]++;    v.push_back(str);//这里我是想着要是输出这个长龙 就保存了    for(int i=0;i<n;i++)    {        if(g[last][i]>0&&used[i]<2)          dfs(str+s[i].substr(g[last][i]),i);    }    used[last]--;}bool cmp(string &a,string &b){ //这里的&不要省略    return a.size()>b.size();}int main(){    cin>>n;    for(int i=0;i<n;i++)    cin>>s[i];    for(int i=0;i<n;i++)    for(int j=0;j<n;j++)    {        string a=s[i],b=s[j];        int len=min(a.size(),b.size());        for(int k=1;k<len;k++)        if(a.substr(a.size()-k)==b.substr(0,k))        {            g[i][j]=k;            break;        }    }    char st;    cin>>st;    for(int i=0;i<n;i++){        if(s[i][0]==st)       dfs(s[i],i);    }    sort(v.begin(),v.end(),cmp);    cout<<v[0].length()<<endl;//输出最长的内个龙就行了}</code></pre><h2 id="P1032-字串变换">P1032 字串变换</h2><blockquote></blockquote><pre class=" language-language-cpp"><code class="language-language-cpp">#include<iostream>#include<algorithm>#include<stdio.h>#include<string>#include<vector>#include<queue>#include<set>#include<map>using namespace std;struct node {    int num;    string s;};string A,B,a,b;set<string>drepe;vector<pair<string,string> >v;bool bfs(){    queue<node>q;    q.push({0,A});    while(q.size()){        node u=q.front();q.pop();        if(u.num>10){printf("NO ANSWER!\n");exit(0);}        for(int i=0;i<v.size();i++){            if(u.s.find(v[i].first)!=-1)            for(int j=u.s.find(v[i].first);j<u.s.length();j=u.s.find(v[i].first,j+1)){                string s=u.s;                s.replace(j,v[i].first.length(),v[i].second);                if(s==B){printf("%d\n",u.num+1);return true;}                if(!drepe.count(s)){                    q.push({u.num+1,s});                    drepe.insert(s);                }            }        }    }}int main(){cin>>A>>B;while(cin>>a>>b){    v.push_back({a,b});}if(!bfs())printf("NO ANSWER!\n");return 0;}</code></pre><h2 id="P1025-数的划分">P1025 数的划分</h2><blockquote><p>sum+i*(k-cur)</p></blockquote><pre class=" language-language-cpp"><code class="language-language-cpp">#include<stdio.h>#include<iostream>using namespace std;int n,k,ans;void dfs(int last,int sum,int cur){  if(cur==k){  //已经选择了k个数了      if(sum==n) ans++; //和也是n  答案加1      return;  }    for(int i=last;sum+i*(k-cur)<=n;i++)      //从上一个开始枚举 因为是要加的数是递增 我们要保证还能 拼进去的个数*当前的数+sum<=n才行    dfs(i,sum+i,cur+1);}int main(){    cin>>n>>k;    dfs(1,0,0);    printf("%d\n",ans);}</code></pre><h2 id="P1157-组合的输出">P1157 组合的输出</h2><blockquote><p>这个就是  递归实现组合型枚举</p></blockquote><pre class=" language-language-cpp"><code class="language-language-cpp">#include<iostream>#include<iomanip>#include<stdio.h>#include<algorithm>#include<vector>using namespace std;vector<int>cho;bool v[101];int n,m;void dfs(int x){    if(cho.size()>m||cho.size()+(n-x)<m)return ;  //个数不满足  退出    if(cho.size()==m){ //满足了  输出        for(int i=0;i<cho.size();i++)       cout<<setw(3)<<cho[i];      //注意哦!输出时，每个数字需要33个场宽  所以用setw（） 在 iomanip中        printf("\n");        return;    }cho.push_back(x); //选择了这个数 dfs(x+1); cho.pop_back(); //回溯 dfs(x+1); //不选择}int main(){    cin>>n>>m;    dfs(1);}</code></pre><h2 id="P1036-选数">P1036 选数</h2><blockquote></blockquote><pre class=" language-language-cpp"><code class="language-language-cpp">#include<iostream>#include<stdio.h>#include<vector>using namespace std;const int N=5100000;int n,cnt,prime[N],m;int st[N],anw;bool vp[N];void get_prime(int n){    for(int i=2;i<=n;i++){        if(!vp[i])prime[cnt++]=i;//是素数 就加进去        for(int j=0;prime[j]<=n/i;j++){            vp[prime[j]*i]=true;  //true为合数            if(i%prime[j]==0)break;        }    }}void dfs(int cur,int sum,int stx){  //cur 现在选择了多少个数  sum当前的和 stx 升序    if(cur==m){        if(!vp[sum]){//是质数 答案加一        anw+=1;        }        return;    }    for(int i=stx;i<n;i++)    dfs(cur+1,sum+st[i],i+1);//步数+1  和也要加 升序 以免算冲    return ;}int main(){    cin>>n>>m;    for(int i=0;i<n;i++)        cin>>st[i];    get_prime(N);  dfs(0,0,0);    cout<<anw<<endl;}</code></pre><h2 id="P1441-砝码称重">P1441 砝码称重</h2><blockquote><p>方案是 放弃m个剩下的 再去算去组合</p></blockquote><pre class=" language-language-cpp"><code class="language-language-cpp">#include<iostream>#include<stdio.h>#include<algorithm>#include<cstring>using namespace std;const int N=2920;int a[N],ans,n,m,tot,ret;bool f[N],v[N];void dp(){    memset(f,0,sizeof f);    f[0]=true;ans=0,tot=0;    for(int i=0;i<n;i++)    {        if(v[i])continue;//这个是抛弃了的秤砣        for(int j=tot;j>=0;j--) if(f[j]&&!f[j+a[i]])f[j+a[i]]=true,ans++; //如果选了j这个秤砣 但是j+a[i]还没有选择        tot+=a[i];    }    ret=max(ret,ans);}void dfs(int cur,int now){//cur是已经选择了的  now是抛弃了的    if(now>m)return;    if(cur==n){        if(now==m)        dp();        return;    }    dfs(cur+1,now);//留下了当前的秤砣    v[cur]=true; //抛弃    dfs(cur+1,now+1); //抛弃了当前的秤砣    v[cur]=false;//擦除痕迹}int main(){    cin>>n>>m;    for(int i=0;i<n;i++)    cin>>a[i];    dfs(0,0);    printf("%d\n",ret);}</code></pre><h2 id="P1378-油滴扩展">P1378 油滴扩展</h2><blockquote></blockquote><pre class=" language-language-cpp"><code class="language-language-cpp">#include<iostream>#include<stdio.h>#include<math.h>#define sq(x) ((x)*(x))using namespace std;struct node{ int x,y; double r;}q[6];const double PI=acos(-1);bool used[6];int n,sx,sy,ex,ey;double ans=1e10;double dist(int x,int y){    return sqrt(sq(x)+sq(y));}double cal(int idx){    double x=q[idx].x,y=q[idx].y;    double r=min(fabs(x-sx),fabs(y-sy));    r=min(r,min(fabs(x-ex),fabs(y-ey)));    for(int i=0;i<n;i++)    if(used[i])          r=min(r,dist(x-q[i].x,y-q[i].y)-q[i].r);      if(r<0) r=0;      return r;}void dfs(int ste){    if(!ste){ //如果n个都遍历完了一次        double sum=0;        for(int i=0;i<n;i++) //计算这样顺序以来的油滴扩展面积大小        sum+=sq(q[i].r)*PI;        sum=abs(sx-ex)*abs(sy-ey)-sum;//矩形面积-油滴面积        ans=min(ans,sum);//保存最小值        return;    }    for(int i=0;i<n;i++){        if(used[i])continue;        else {            q[i].r=cal(i);            used[i]=1;            dfs(ste-1);            used[i]=q[i].r=0;        }    }}int main(){    cin>>n>>sx>>sy>>ex>>ey;    for(int i=0;i<n;i++)    cin>>q[i].x>>q[i].y;    dfs(n);    printf("%0.0lf\n",ans);}</code></pre><h2 id="P1034-矩形覆盖">P1034 矩形覆盖</h2><blockquote></blockquote><pre class=" language-language-cpp"><code class="language-language-cpp">#include<iostream>#include<stdio.h>#include<algorithm>#include<cstring>#define sq(x) ((x)*(x))using namespace std;const int N=51;struct node{    int lx,ly,rx,ry;//记录的是坐标    bool cnt;    void add(int x,int y){        if(!cnt){            lx=rx=x;            ly=ry=y;            cnt=1;        }else {            if(x<lx)lx=x;            else if(x>rx)rx=x;            if(y>ly) ly=y;            else if(y<ry)ry=y;        }    }    bool innode(int x,int y)const{        return lx<=x&&x<=rx&&ry<=y&&y<=ly;    }    int operator()(){        if(!cnt)return 0;        return (rx-lx)*(ly-ry);    }    bool operator*(const node &p){        if(!cnt||!p.cnt)return 0;        return p.innode(lx,ly)||p.innode(lx,ry)||p.innode(rx,ly)||p.innode(rx,ry);    }}q[6];int n,k,ans=1e10;int x[N],y[N];bool check(){    for(int i=1;i<=k;i++)    for(int j=i+1;j<=k;j++)    if(q[i]*q[j])return 0;    return 1;}void dfs(int idx,int area){//计算到了第idx个点，面积是多少    if(area>=ans) return;    if(idx==n){      if(check())         if(ans>area)ans=area;       return;    }     node temp;    for(int i=1;i<=k;i++)    {        temp=q[i];        q[i].add(x[idx],y[idx]);        dfs(idx+1,area-temp()+q[i]());        q[i]=temp;    }}int main(){    cin>>n>>k;    for(int i=0;i<n;i++){    cin>>x[i]>>y[i];    }    dfs(0,0);    cout<<ans;}</code></pre><h2 id="P1665-正方形计数">P1665 正方形计数</h2><p><a href="https://www.luogu.com.cn/blog/GetKeyState/solution-p1665" target="_blank" rel="noopener">参考博客</a></p><pre class=" language-language-cpp"><code class="language-language-cpp">#include<iostream>#include<stdio.h>#include<algorithm>using namespace std;const int N=1000;int x[N],y[N];int n,ans=0;bool g[N+10][N+10];int main(){    cin>>n;    for(int i=1;i<=n;++i)    {    cin>>x[i]>>y[i];    x[i]=(x[i]+51)<<1,y[i]=(y[i]+51)<<1;    g[x[i]][y[i]]=1;    //cout<<x[i]<<' '<<y[i]<<endl;    }     for(int i=1;i<n;++i)    for(int j=i+1;j<=n;++j){         int midx=(x[i]+x[j])/2; //中点         int midy=(y[i]+y[j])/2;         int x1=midx-(midy-y[i]),y1=midy+(midx-x[i]);         int x2=midx+(midy-y[i]),y2=midy-(midx-x[i]);      if(x1 <= 0) continue; if(x2 <= 0) continue;            if(y1 <= 0) continue; if(y2 <= 0) continue;         if(g[x1][y1]&&g[x2][y2]) ans++;    }    printf("%d\n",ans>>1);}</code></pre><h2 id="P1219-USACO1-5-八皇后-Checker-Challenge">P1219 [USACO1.5]八皇后 Checker Challenge</h2><blockquote><p>可以先去做做下面的题</p></blockquote><p><a href="https://www.acwing.com/problem/content/845/" target="_blank" rel="noopener">Acwing N-皇后</a></p><pre class=" language-language-cpp"><code class="language-language-cpp">#include<iostream>#include<stdio.h>#include<algorithm>#include<vector>#include<map>using namespace std;const int N=1000;int n,ans,sum=0;vector<pair<int,int> >q;bool col[N],row[N],dg[N],udg[N];// col 列 row 行  dg 主对角线 usg 副对角线void dfs(int x){    if(x==n){            ans++;            if(sum<3){                sum++;           sort(q.begin(),q.end());           for(int i=0;i<n;i++)           printf("%d ",q[i].second);           printf("\n");            }else if(sum==3){                return ;                q.clear();            }        return ;    }   for(int i=0;i<n;i++){    if(!col[i]&&!dg[x+i]&&!udg[n-x+i]){        col[i]=dg[x+i]=udg[n-x+i]=1;        q.push_back({x,i+1});        dfs(x+1);         col[i]=dg[x+i]=udg[n-x+i]=0;        q.pop_back();    }   }}int main(){    cin>>n;    dfs(0);    printf("%d\n",ans);    return 0;}</code></pre><h2 id="P1406-方格填数">P1406 方格填数</h2><pre class=" language-language-cpp"><code class="language-language-cpp">#include<iostream>#include<algorithm>#include<stdio.h>using namespace std;const int N=20;int n,a[20],sum,ans[N][N];bool v[N];bool is(){    int cnt=0;    for(int i=1;i<=n;i++){        cnt=0;        for(int j=1;j<=n;j++)            cnt+=ans[i][j];            if(cnt!=sum)return 0;    }    for(int j=1;j<=n;j++)    {        cnt=0;        for(int i=1;i<=n;i++)        cnt+=ans[i][j];        if(cnt!=sum)return 0;    }    cnt=0;    for(int i=1;i<=n;i++)    cnt+=ans[i][i];    if(cnt!=sum)return 0;    cnt=0;    for(int i=1;i<=n;i++)cnt+=ans[i][n-i+1];    if(cnt!=sum)return 0;    return 1;}void dfs(int x,int y,int s){//s当前行所有数之和    if(y==n+1){        y=1,x++;        if(s!=sum)return;        s=0;    }    if(x==n+1){        if(is()==1){            for(int i=1;i<=n;i++){                for(int j=1;j<=n;j++)                printf("%d ",ans[i][j]);                cout<<endl;            }         exit(0);        }        else return ;    }    for(int i=1;i<=n*n;i++)    {        if(!v[i]){            v[i]=1;ans[x][y]=a[i];            dfs(x,y+1,s+a[i]);            v[i]=0;ans[x][y]=0;        }    }}int main(){ cin>>n; for(int i=1;i<=n*n;i++){    cin>>a[i];     sum+=a[i]; } sort(a+1,a+n*n+1); sum/=n; printf("%d\n",sum);    dfs(1,1,0);    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【普及】算法入门学习 题单</title>
      <link href="/2020/082164788.html"/>
      <url>/2020/082164788.html</url>
      
        <content type="html"><![CDATA[<h1>【普及】算法入门学习 题单</h1><p><a href="https://www.luogu.com.cn/training/2929#problems" target="_blank" rel="noopener">提单入口</a></p><h2 id="P3371-单元最短路径（弱化版）">P3371 单元最短路径（弱化版）</h2><blockquote><p>很裸的一个模板题 我的求解方法是   堆优化的Dijkstra()算法 <s>这里有时间会更新</s></p></blockquote><pre class=" language-language-c"><code class="language-language-c">#include<iostream>#include<algorithm>#include<stdio.h>#include<cstring>#include<queue>#include<map>using namespace std;const int N=10100,M=N*50;int h[N],e[M],ne[M],ver[M],idx,d[M],n,m,s,x,y,z;bool v[M];priority_queue<pair<int,int> >q;void add(int x,int y,int z){    ver[++idx]=y,e[idx]=z,ne[idx]=h[x],h[x]=idx; //++ 要在前面}void dijstra(){    memset(d,0x3f,sizeof d);    memset(v,0,sizeof(v));     d[s]=0;     q.push({0,s});     while(q.size()){         int x=q.top().second; q.pop();         if(v[x])continue;         v[x]=1;         for(int i=h[x];i;i=ne[i]){             int y=ver[i],z=e[i];             if(d[y]>d[x]+z)             d[y]=d[x]+z;             q.push({-d[y],y});         }     }}int main(){//cin>>n>>m>>s;for(int i=1;i<=m;i++){    scanf("%d%d%d",&x,&y,&z);    add(x,y,z);}    dijstra();    for(int i=1;i<=n;i++)    if(d[i]<0x3f3f3f3f)    printf("%d ",d[i]);    else printf("%d ",(1<<31)-1);  //提一句  要加括号}</code></pre><h2 id="P3367并查集">P3367并查集</h2><blockquote><p>并查集的基础</p></blockquote><pre class=" language-language-c"><code class="language-language-c">#include<iostream>#include<stdio.h>#include<algorithm>using namespace std;const int N=10010,M=N*20;int fa[M],n,m,z,x,y;int get(int x){    if(x==fa[x]) return x;    else return fa[x]=get(fa[x]);}void merge(int x,int y){    fa[get(x)]=get(y);}int main(){  //cin>>n>>m;  for(int i=1;i<=n;i++)fa[i]=i;  for(int i=1;i<=m;i++)  {      //cin>>z>>x>>y;      if(z==1){          merge(x,y);      }      else {      int a=get(x);      int b=get(y);      if(a==b)      printf("Y\n");      else printf("N\n");      }  }}</code></pre><h2 id="P1226-【模板】快速幂-取余运算">P1226 【模板】快速幂||取余运算</h2><blockquote><p>很裸的题目</p></blockquote><pre class=" language-language-c"><code class="language-language-c">#include<iostream>#include<stdio.h>using namespace std;typedef long long ll;ll a,b,p;ll power(ll a,ll b,ll p){    ll ans=1%p;    while(b){        if(b&1)ans=ans*a%p;        a=a*a%p;        b>>=1;    }    return ans;}int main(){    //cin>>a>>b>>p;    ll ans=power(a,b,p);    printf("%lld^%lld mod %lld=%lld ",a,b,p,ans);}</code></pre><h2 id="P1177-【模板】快速排序">P1177 【模板】快速排序</h2><blockquote><p>裸题  稍后请看我的排序总结</p></blockquote><pre class=" language-language-c"><code class="language-language-c">#include<iostream>#include<stdio.h>#include<algorithm>using namespace std;const int N=100100;int a[N],n;void quick_sort(int a[],int l,int r){    if(l>=r) return;    int x=a[(l+r)>>1],i=l-1,j=r+1;    while(i<j){        do i++;while(a[i]<x);        do j--;while(a[j]>x);        if(i<j) swap(a[i],a[j]);    }    quick_sort(a,l,j);    quick_sort(a,j+1,r);}int main(){    // cin>>n;    for(int i=0;i<n;i++)    scanf("%d",&a[i]);    quick_sort(a,0,n-1);    for(int i=0;i<n;i++)    printf("%d ",a[i]);}</code></pre><h2 id="P3370-【模板】字符串哈希">P3370 【模板】字符串哈希</h2><blockquote><p>把字符串变为p进制的数</p></blockquote><pre class=" language-language-c"><code class="language-language-c">#include<iostream>#include<stdio.h>#include<algorithm>#include<cstring>using namespace std;const int N=100100;typedef unsigned long long ull;ull p=131,mod=1<<31;int n;int a[N],ans;char s[10010];int hashstr(char s[]){    int len=strlen(s);    int ans=0;    for(int i=0;i<len;i++){        ans=(ans*p+(ull)s[i])%mod;   //一定要用unsigned long long  让字符 变为ASCII    }    return ans;}int main(){    //cin>>n;    for(int i=0;i<n;i++){        scanf("%s",s);        a[i]=hashstr(s);    }    sort(a,a+n);    for(int i=0;i<n;i++)    {        if(a[i]!=a[i+1])        ans++;    }    //cout<<ans<<endl;}</code></pre><h2 id="P3378-【模板】堆">P3378 【模板】堆</h2><blockquote><p>emm  可以用STL小根堆</p><p>priority_queue&lt;Type, Container, Functional&gt;</p><p>默认是大根堆    <code>priority_queue&lt;int&gt;q</code></p><p>小根堆<code>priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;q</code>;</p><p>堆得操作和队列基本操作相同:</p><ul><li>top 访问队头元素</li><li>empty 队列是否为空</li><li>size 返回队列内元素个数</li><li>push 插入元素到队尾 (并排序)</li><li>emplace 原地构造一个元素并插入队列</li><li>pop 弹出队头元素</li><li>swap 交换内容</li></ul></blockquote><pre class=" language-language-c"><code class="language-language-c">#include<stdio.h>#include<vector>#include<queue>#include<iostream>#include<algorithm>using namespace std;priority_queue<int,vector<int>,greater<int> >heap;int n,op,x;int main(){    //cin>>n;    for(int i=1;i<=n;i++){      scanf("%d",&op);        if(op==1){            scanf("%d",&x);            heap.push(x);        }        else if(op==2){            //cout<<heap.top()<<endl;        }else        heap.pop();    }}</code></pre><blockquote><p>手写堆 <s>我不会写，只能像博客中所说的，多写几遍</s><a href="https://www.luogu.com.cn/blog/Kesdiael3/solution-p3378" target="_blank" rel="noopener">链接</a></p></blockquote><pre class=" language-language-c"><code class="language-language-c">#include<stdio.h>#include<iostream>#include<algorithm>using namespace std;int heap[10000000]; //模拟堆int hsize=0;  //堆得大小，也是堆得最后一个元素的编号inline void _insert(int node,int num){ //插入函数，将元素插入到最后的叶节点，往上走，直到父节点小于他    heap[node]=num;//先在最后的节点赋值    if(heap[node>>1]>num) //判断父节点是否大于它    不大于 就满足了小根堆的要求 没必要往上面交换了    {        heap[node]=heap[node>>1];        _insert(node>>1,num);//交换父子节点位置递归    }}inline void _pop(int node,int num){ //删除堆顶数据    heap[node]=num;//直接把最后一个数 拿过来 当做堆顶 然后在交换数据 满足小根堆要求    if((node<<1)<=hsize&&(num>heap[node<<1]||num>heap[(node<<1)|1])){ //判断他的左右子节点是不是大于他 要是根节点  <<1之后为0 无碍        heap[node]=min(heap[node<<1],heap[node<<1|1]);//找它俩之间的最小值        _pop(heap[node<<1]<heap[node<<1|1]?node<<1:(node<<1)|1,num); //让这俩之间的最小值 节点 再去和他的子节点比较                                                                    //选出最小值 如此循环，直到是小根堆为止    }}int main(){    int n,op,x;    scanf("%d",&n);    for(int i=1;i<=n;i++){        scanf("%d",&op);        if(op==1){scanf("%d",&x);_insert(++hsize,x);}//在最后节点插入        if(op==2){printf("%d\n",heap[1]);} // 堆顶是1        if(op==3){_pop(1,heap[hsize--]);} //让堆顶 是最后一个节点的值，    }}</code></pre><h2 id="P3383-【模板】线性筛素数">P3383 【模板】线性筛素数</h2><blockquote><p>这个可以看我的另一篇文章</p></blockquote><p><a href="http://arbor1.top/2020/081416648.html#toc-heading-4" target="_blank" rel="noopener">点击即可获取知识</a></p><pre class=" language-language-c"><code class="language-language-c">#include<iostream>#include<stdio.h>#include<algorithm>using namespace std;const int N=100000100;int primes[N],cnt,n,q,x;bool v[N];void get_primes(int n){    for(int i=2;i<=n;i++){        if(!v[i])primes[cnt++]=i;        for(int j=0;primes[j]<=n/i;j++){            v[primes[j]*i]=true;            if(i%primes[j]==0)break;        }    }}int main(){    scanf("%d%d",&n,&q);    get_primes(n);    while(q--){    scanf("%d",&x);    printf("%d\n",primes[x-1]);    }}</code></pre><h2 id="P3366-【模板】最小生成树">P3366 【模板】最小生成树</h2><blockquote><p>prim算法</p></blockquote><pre class=" language-language-c"><code class="language-language-c">#include<iostream>#include<algorithm>#include<stdio.h>#include<cstring>using namespace std;const int N=5010;bool v[N];int a[N][N],d[N],n,m,ans;void prim(){ memset(d,0x3f,sizeof d); d[1]=0;    for(int i=1;i<n;i++){        int x=0;        for(int j=1;j<=n;j++)        if(!v[j]&&(x==0||d[j]<d[x]))x=j;        v[x]=1;        for(int y=1;y<=n;y++)            if(!v[y]) d[y]=min(d[y],a[x][y]);    }}int main(){    scanf("%d%d",&n,&m);memset(a,0x3f,sizeof a);memset(v,0,sizeof v);for(int i=1;i<=n;i++) a[i][i]=0;for(int i=1;i<=m;i++){    int x,y,z;    scanf("%d%d%d",&x,&y,&z);    a[x][y]=a[y][x]=min(a[x][y],z);}prim();for(int i=1;i<=n;i++)   ans+=d[i];printf("%d\n",ans);}</code></pre><h2 id="P4779-【模板】单源最短路径（标准版）">P4779 【模板】单源最短路径（标准版）</h2><blockquote><p>裸 的堆优化的Dijkstra</p></blockquote><pre class=" language-language-c"><code class="language-language-c">#include<iostream>#include<stdio.h>#include<map>#include<cstring>#include<queue>using namespace std;const int N=12010,M=2*N;priority_queue<pair<int,int> >q;int x,y,z,d[M];bool v[M];int n,m,e[M],ne[M],h[N],ver[M],idx,s;void add(int x,int y,int z){    ver[++idx]=y,e[idx]=z,ne[idx]=h[x],h[x]=idx;}void dijkstra(){    d[s]=0;    q.push({0,s});    while(q.size()){     int x=q.top().second;q.pop();     if(v[x])continue;     v[x]=1;     for(int i=h[x];i;i=ne[i]){      int y=ver[i],z=e[i];      if(d[y]>d[x]+z){      d[y]=d[x]+z;if(!v[y])       q.push({-d[y],y});      }     }    }}int main(){    scanf("%d%d%d",&n,&m,&s);    memset(d,0x3f,sizeof d);    for(int i=1;i<=m;i++){        scanf("%d%d%d",&x,&y,&z);        add(x,y,z);    }    dijkstra();    for(int i=1;i<=n;i++)    printf("%d ",d[i]);}</code></pre><h2 id="P3390-【模板】矩阵快速幂">P3390 【模板】矩阵快速幂</h2><blockquote><p>模板</p></blockquote><pre class=" language-language-c"><code class="language-language-c">#include<iostream>#include<stdio.h>#include<algorithm>using namespace std;const int Mod=1000000007;long long n,k;struct Matrix{    long long  c[101][101];}A,I;Matrix operator*(const Matrix &x,const Matrix &y){    Matrix a;    for(int i=1;i<=n;i++)    for(int j=1;j<=n;j++)    a.c[i][j]=0;    for(int i=1;i<=n;i++ )    for(int j=1;j<=n;j++)    for(int k=1;k<=n;k++){        a.c[i][j]+=(x.c[i][k]*y.c[k][j])%Mod;        a.c[i][j]%=Mod;    }    return a;}int main(){    scanf("%lld%lld",&n,&k);    for(int i=1;i<=n;i++)    for(int j=1;j<=n;j++)    //cin>>A.c[i][j];    for(int i=1;i<=n;i++) I.c[i][i]=1;    while(k>0){        if(k&1)I=I*A;        A=A*A;        k>>=1;    }    for(int i=1;i<=n;i++){    for(int j=1;j<=n;j++)   printf("%lld ",I.c[i][j]);    printf("\n");    }    return 0;}</code></pre><h2 id="P3375-【模板】KMP字符串匹配">P3375 【模板】KMP字符串匹配</h2><blockquote><p>最后一行是输出 next数组  即0 0 1</p><p>除了最后一行 上面的答案都是找  ABA 在ABABABC哪里出现的</p></blockquote><pre class=" language-language-c"><code class="language-language-c">#include<iostream>#include<stdio.h>#include<cstring>#include<string>#include<algorithm>using namespace std;const int N = 1000100;char s[N], p[N];int ne[N],len,lenp;void getnext() {    for (int i = 2, j = 0; i <= lenp; i++)    {        while (j && p[i] != p[j + 1])j = ne[j];        if (p[i] == p[j + 1])j++;        ne[i] = j;    }}void kmp() {    for (int i = 1, j = 0; i <= len; i++)    {        while (j && s[i] != p[j + 1])j = ne[j];        if (s[i] == p[j + 1])j++;        if (j == lenp) {            printf("%d\n", i - lenp+1);            j = ne[j];        }    }}int main() {    scanf("%s",s+1);  scanf("%s",p+1);    len = strlen(s+1);     lenp = strlen(p+1);    getnext();    kmp();    for (int i = 1; i <= lenp; i++)        printf("%d ", ne[i]);}</code></pre><h2 id="P1195-口袋的天空">P1195 口袋的天空</h2><blockquote><p>题意大概就是 分成多个最小生成树的代价最小</p><p>分成m颗树 需要 n-m条边</p></blockquote><pre class=" language-language-c"><code class="language-language-c">#include<iostream>#include<stdio.h>#include<algorithm>using namespace std;const int N=10010;struct node{    int x,y,z;}e[N];bool cmp(node a,node b){    return a.z<b.z;}int fa[N];int x,y,l,n,m,k,tn;long long ans;int get(int x){    if(x==fa[x])return x;    return fa[x]=get(fa[x]);}int main(){    scanf("%d%d%d",&n,&m,&k);    tn=n;    for(int i=1;i<=m;i++){        scanf("%d%d%d",&e[i].x,&e[i].y,&e[i].z);    }    sort(e+1,e+m+1,cmp);    for(int i=1;i<=n;i++)fa[i]=i;    for(int i=1;i<=m;i++){       if(tn<=k)break;  //是否建成了k棵树，要是tn<k 就不能建成       int x=get(e[i].x);       int y=get(e[i].y);        if(x!=y){  //他们两个不是连通的 可以多出来一棵树            fa[x]=y;            ans+=e[i].z;            tn--; //多出来一棵树        }    }    if(tn==k)   printf("%d",ans);    else printf("No Answer\n");}</code></pre><h2 id="P1051-谁拿了最多奖学金">P1051 谁拿了最多奖学金</h2><blockquote><p>水</p></blockquote><pre class=" language-language-c"><code class="language-language-c">#include<iostream>#include<algorithm>using namespace std;int main(){    int n,score1,score2,sum=0,max=0,total=0,x,i;    char a,b;    string name,maxn;scanf("%d",&n);    for(i=1;i<=n;i++)    {        //cin>>name>>score1>>score2>>a>>b>>x;        if(score1>80 && x>0)//判断是否获得院士奖学金            sum+=8000;        if(score1>85 && score2>80)//判断是否获得五四奖学金            sum+=4000;        if(score1>90)//判断是否获得成绩优秀奖            sum+=2000;        if(score1>85 && b=='Y')//判断是否获得西部奖学金            sum+=1000;        if(score2>80 && a=='Y')//判断是否获得班级贡献奖            sum+=850;        total+=sum;//累加奖学金        if(sum>max)//找出最牛学生            maxn=name,max=sum;//sum的用处        sum=0;    } //   cout<<maxn<<endl<<max<<endl<<total;    return 0;}</code></pre><h2 id="P1359-租用游艇">P1359 租用游艇</h2><blockquote><p>输入的时候 要注意点他说的半矩阵</p><p>是      1-2 1-3</p><p>​         2-3</p><p>我们存的时候</p><p>1-2  1-3</p><p>​            2-3</p></blockquote><pre class=" language-language-c"><code class="language-language-c">#include<iostream>#include<cstring>#include<stdio.h>#include<algorithm>using namespace std;const int N=1010;int d[N][N];int n,x;int main(){    scanf("%d",&n);    memset(d,0x3f,sizeof(d));    for(int i=1;i<=n;i++)    {         for(int j=i+1;j<=n;j++ )          {              scanf("%d",&x);              d[i][j]=min(d[i][j],x);          }    }     for(int k=1;k<=n;k++) //k放在第一位  就行    for(int i=1;i<=n;i++)    for(int j=1;j<=n;j++)   {        d[i][j]=min(d[i][k]+d[k][j],d[i][j]);    }    //cout<<d[1][n]<<endl;}</code></pre><h2 id="P1056-排座椅">P1056 排座椅</h2><blockquote><p>就按照模拟来吧</p></blockquote><pre class=" language-language-c"><code class="language-language-c">#include<iostream>#include<stdio.h>#include<algorithm>using namespace std;const int N=10010;int m,n,k,l,d;struct node{    int n,p;//几个 哪条线}c[N],r[N];// 列 行   行是m  列是nint x,y,x1,y1;bool cmp(node a,node b){ //按次序输出 方便输出用    return a.p<b.p;}bool cmp1(node a,node b){ // 把分割次数多的往前搞    return a.n>b.n;}int main(){    scanf("%d%d%d%d%d",&m,&n,&k,&l,&d);    for(int i=1;i<=d;i++){        scanf("%d%d%d%d",&x,&y,&x1,&y1);        if(x==x1){ //在一行上            c[min(y,y1)].p=min(y,y1); //取最小的列分开它            c[min(y,y1)].n++; //这个 列  用到的次数+1        }        else{            r[min(x,x1)].p=min(x,x1);            r[min(x,x1)].n++;        }    }    sort(c+1,c+n+1,cmp1);    sort(c+1,c+l+1,cmp);    sort(r+1,r+m+1,cmp1);    sort(r+1,r+k+1,cmp);    for(int i=1;i<=k;i++)printf("%d ",r[i].p);    printf("\n");    for(int i=1;i<=l;i++)printf("%d ",c[i].p);}</code></pre><h2 id="P1111-修复公路">P1111 修复公路</h2><blockquote><p>求出最小生成树中权值最大是多少</p></blockquote><pre class=" language-language-c"><code class="language-language-c">#include<iostream>#include<stdio.h>#include<algorithm>using namespace std;const int N=1001,M=100010;int fa[M];int n,m;struct node{    int x,y,z;}e[M];bool operator<(node a,node b){    return a.z<b.z;}int get(int x){    if(x==fa[x])return x;    return fa[x]=get(fa[x]);}int kruskal(){   int ans=0,k=0;    for(int i=1;i<=m;i++){        int x=get(e[i].x);        int y=get(e[i].y);        if(x==y) continue;        fa[x]=y;        k++;         ans=max(ans,e[i].z);    }    if(k==n-1) //边数是n-1的时候  n个点才能生成最小生成树    return ans;    else    return -1;}int main(){    scanf("%d%d",&n,&m);    for(int i=1;i<=n;i++)fa[i]=i;    for(int i=1;i<=m;i++)    {        scanf("%d%d%d",&e[i].x,&e[i].y,&e[i].z);    }    sort(e+1,e+m+1);    int ans=kruskal();    printf("%d ",ans);}</code></pre><h2 id="P1158-导弹拦截">P1158 导弹拦截</h2><blockquote><p>我们首先要知道，一个导弹，不是一号系统消灭他，就是2号系统消灭他</p><p>我们的任务就是 找到导弹距离一号系统最远的时候，距离二号多远</p><p>导弹距离二号最远的时候，距离一号多远</p><p>下面这个是 代码产生的样例2的结果</p><p>找到第一列 最远是82 第二列最远是104</p><p>我们就找到了答案</p><pre class=" language-language-c"><code class="language-language-c">13 7316 420 10440 482 10</code></pre></blockquote><pre class=" language-language-c"><code class="language-language-c">#include<iostream>#include<stdio.h>#include<algorithm>#include<vector>using namespace std;const int M=100100;struct node{    int l1,l2;}q[M];int n;int  x1,y1,x2,y2;bool cmp(node a,node b){ //距离一号最远的排到最后面   return a.l1<b.l1;}int main(){    scanf("%d%d%d%d",&x1,&y1,&x2,&y2);    scanf("%d",&n);    for(int i=1;i<=n;i++){     int x,y;        scanf("%d%d",&x,&y);        q[i].l1=(x1-x)*(x1-x)+(y1-y)*(y1-y);        q[i].l2=(x2-x)*(x2-x)+(y2-y)*(y2-y);    }    sort(q+1,q+n+1,cmp);  int r2=0,ans=q[n].l1;   //我们先找到了距离一号系统最远的导弹    for(int i=n-1;i>=1;i--){     //n-1是假设 第n号导弹被二号系统消灭了        if(r2<q[i+1].l2) r2=q[i+1].l2; // 因为两个系统总是错开着  所以一定可以找到 对于两个系统各自最近最远的两个点  就是两个半径        ans=min(ans,r2+q[i].l1);//    }printf("%d ",ans);}</code></pre><h2 id="P1629-邮递员送信">P1629 邮递员送信</h2><blockquote><p>两遍 spfa即可</p></blockquote><p><a href="https://arbor1.top/2020/081819070.html#toc-heading-4" target="_blank" rel="noopener">spfa链接</a></p><pre class=" language-language-c"><code class="language-language-c">#include<iostream>#include<stdio.h>#include<cstring>#include<queue>#include<algorithm>using namespace std;const int N=100101,M=2*N;int h[N],ne[M],e[M],ver[M],idx,d[M];int h1[N],ne1[M],e1[M],ver1[M],idx1,d1[M];int ans1,ans2;bool v[M],v1[M];int n,m,a,b,z;queue<int>q;queue<int>q1;void add(int x,int y,int v){    ver[++idx]=y,e[idx]=v,ne[idx]=h[x],h[x]=idx;}void add1(int x,int y,int v){    ver1[++idx1]=y,e1[idx1]=v,ne1[idx1]=h1[x],h1[x]=idx1;}void spfa(int st){    memset(d,0x3f,sizeof d);    memset(v,0,sizeof v);    d[st]=0,v[st]=1;    q.push(st);    while(q.size()){        int x=q.front();q.pop();        v[x]=0;        for(int i=h[x];i;i=ne[i]){         int y=ver[i],z=e[i];            if(d[y]>d[x]+z){         d[y]=d[x]+z;         if(!v[y])q.push(y),v[y]=1;         }        }    }}void spfa1(int st){    memset(d1,0x3f,sizeof d1);    memset(v1,0,sizeof v1);    d1[st]=0,v1[st]=1;    q1.push(st);    while(q1.size()){        int x=q1.front();q1.pop();        v1[x]=0;       for(int i=h1[x];i;i=ne1[i]){           int y=ver1[i],z=e1[i];           if(d1[y]>d1[x]+z){               d1[y]=d1[x]+z;               if(!v1[y]) q1.push(y),v1[y]=1;           }       }    }}int main(){    scanf("%d%d",&n,&m);    for(int i=1;i<=m;i++){        scanf("%d%d%d",&a,&b,&z);        add(a,b,z);        add1(b,a,z);                //这里得是反向边 ！！！    }    spfa(1);    spfa1(1);    for(int i=1;i<=n;i++){        ans1+=d[i];        ans2+=d1[i];    }    printf("%d ",ans1+ans2);    return 0;}</code></pre><h2 id="P5651-基础最短路练习题">P5651 基础最短路练习题</h2><blockquote><p>dijkstra 算法</p></blockquote><pre class=" language-language-c"><code class="language-language-c">#include<iostream>#include<stdio.h>#include<cstring>#include<map>#include<queue>using namespace std;const int N=1000100,M=N*2;int h[N],e[M],ne[M],ver[M],idx,n,m,p,cnt;long long d[M];bool v[M];priority_queue<pair<int,int> >q;void add(int x,int y,int z){    ver[++idx]=y,e[idx]=z,ne[idx]=h[x],h[x]=idx;}void  dijkstra(int st){    memset(d,0x3f,sizeof d);    memset(v,0,sizeof v);    d[st]=0;    q.push({0,st});    while(q.size()){        int x=q.top().second;q.pop();        if(v[x])continue;        v[x]=1;        for(int i=h[x];i;i=ne[i]){            int y=ver[i],z=e[i];            if(!v[y]) //这里是和dijkstra算法不一样的地方            {                d[y]=d[x]^z;                q.push({-d[y],y});            }        }    }}int main(){    scanf("%d%d%d",&n,&m,&p);    for(int i =1;i<=m;i++){        int a,b,z;        scanf("%d%d%d",&a,&b,&z);        add(a,b,z),add(b,a,z);    }    dijkstra(1); for(int i=1;i<=p;i++)   {       int x,y;       scanf("%d%d",&x,&y);       printf("%d\n",d[x]^d[y]);   }    return 0;}</code></pre><h2 id="P1396-营救">P1396 营救</h2><blockquote><p>克鲁斯卡尔算法 当s和t的<code>祖父节点</code>相同时就是答案</p></blockquote><pre class=" language-language-c"><code class="language-language-c">#include<iostream>#include<stdio.h>#include<algorithm>using namespace std;const int N=100010;int fa[N],n,m,d[N],s,t;struct node{    int a,b,z;}e[N];int get(int x){    if(x==fa[x])return fa[x];    return fa[x]=get(fa[x]);}bool cmp(node a,node b){    return a.z<b.z;}int main(){    scanf("%d%d%d%d",&n,&m,&s,&t);    for(int i=1;i<=n;i++)fa[i]=i;    for(int i=1;i<=m;i++){        scanf("%d%d%d",&e[i].a,&e[i].b,&e[i].z);    }    sort(e+1,e+m+1,cmp);    for(int i=1;i<=m;i++){        int x=get(e[i].a);        int y=get(e[i].b);        if(x!=y)           fa[x]=y;       if(get(s)==get(t))       {           printf("%d ",e[i].z);           return 0;       }    }}</code></pre><h2 id="P1122-最大子树和">P1122 最大子树和</h2><blockquote><p>树形dp问题</p></blockquote><pre class=" language-language-c"><code class="language-language-c">#include<iostream>#include<stdio.h>#include<algorithm>#include<cstring>using namespace std;const int N=100100,M=2*N;int h[N],ne[M],ver[M],idx;int n,r[M],f[M],ans;bool v[M];void add(int x,int y){    ver[++idx]=y,ne[idx]=h[x],h[x]=idx;}void dp(int x,int fa){   f[x]=r[x];//开始的时候 直接给f[x]赋值魅力值   for(int i=h[x];i;i=ne[i]){       int y=ver[i]; //找到了x的儿子       if(y!=fa){ //因为是两条边都加了，所以要特判一下，y不是x的father           dp(y,x); //就继续往下找y的儿子           f[x]+=max(0,f[y]);//此时汇聚到x的花朵魅力指数 要加上y的魅力指数       }   }   ans=max(ans,f[x]); //返回最大值就行}int main(){    scanf("%d",&n);    for(int i=1;i<=n;i++)scanf("%d",&r[i]);//把花朵自身的魅力指数读进来    for(int i=1;i<n;i++){        int x,y;        scanf("%d%d",&x,&y);        add(x,y);add(y,x); //添加两条边    }    dp(1,0); //无根树，从哪里开始都可以    printf("%d",ans);}</code></pre><h2 id="Radio-Transmission-无线传输">Radio Transmission 无线传输</h2><blockquote><p>KMP 算法</p><p>求next数组</p><p>这题的题意很简单，在一个字符串中找出最小周期</p><p>无论周期为多少，最长前缀一定匹配到和最后一个字符相同的前一个字符，而最长后缀一定匹配到和第一个字符相同的后一个字符，所以中间刚好空了一整个周期</p></blockquote><p><a href="https://www.acwing.com/problem/content/description/833/" target="_blank" rel="noopener">KMP模板习题</a></p><pre class=" language-language-c"><code class="language-language-c">#include<iostream>#include<stdio.h>using namespace std;const int N=1001000;char s[N],p[N];int n,m,ne[N];int main(){   scanf("%d",&n);  scanf("%s",p+1);  scanf("%d",&m);  scanf("%s",s+1);    for(int i=2,j=0;i<=n;i++){        while(j!=0&&p[i]!=p[j+1])j=ne[j];        if(p[i]==p[j+1])j++;        ne[i]=j;    }    for(int i=1,j=0;i<=m;i++){        while(j!=0&&s[i]!=p[j+1])j=ne[j];        if(s[i]==p[j+1])j++;        if(j==n){          printf("%d ",i-n);            j=ne[j];        }    }}</code></pre><pre class=" language-language-c"><code class="language-language-c">#include<iostream>#include<stdio.h>#include<algorithm>#include<cstring>using namespace std;const int N=1000100;char p[N];int ne[N],n;void getne(char p[]){    int j=0;    for(int i=2;i<=n;i++){        while(j&&p[i]!=p[j+1])j=ne[j];        if(p[i]==p[j+1]) j++;        ne[i]=j;    }}int main(){    scanf("%d",&n);    scanf("%s",p+1);    getne(p);    printf("%d",n-ne[n]);}</code></pre><h2 id="P2820-局域网">P2820 局域网</h2><blockquote><p>找到最小生成树，用所有边的和- 组成最小生成树边的和</p></blockquote><pre class=" language-language-c"><code class="language-language-c">#include<stdio.h>#include<algorithm>#include<cstring>using namespace std;const int N=100100;struct node{    int x,y,z;}e[N];bool cmp(node a,node b){    return a.z<b.z;}int fa[N],n,m,ans,sum1;int get(int x){    if(x==fa[x])return x;    return fa[x]=get(fa[x]);}int main(){    scanf("%d%d",&n,&m);    for(int i=1;i<=m;i++){        scanf("%d%d%d",&e[i].x,&e[i].y,&e[i].z);        sum1+=e[i].z;    }    sort(e+1,e+m+1,cmp);    for(int i=1;i<=n;i++)fa[i]=i;    for(int i=1;i<=m;i++){        int x=get(e[i].x);        int y=get(e[i].y);        if(x==y)continue;        fa[x]=y;        ans+=e[i].z;    }    printf("%d",sum1-ans);}</code></pre><h2 id="P2085-最小函数值">P2085 最小函数值</h2><blockquote><p>因为a b 的值都是正数，最小值是  在 -b/2a  在坐标轴的左侧，右侧的数是单调递增的</p><p>我们可以每次只找每组a b c的前m个最小值  复杂度为O(nm) 最坏是 1*10^8 不知为啥可Ac</p></blockquote><pre class=" language-language-c"><code class="language-language-c">using namespace std;const int N=10100;priority_queue<int>q;int ans[N],a,b,c,n,m;int main(){   scanf("%d%d",&n,&m);   for(int i=1;i<=n;i++){ //n组a b c       scanf("%d%d%d",&a,&b,&c);       for(int j=1;j<=m;j++){//每次就只找a b c的前m个值           int k=a*j*j+b*j+c;           if(i==1) q.push(k);//第一个数先加进去           else {               if(k<q.top()) //小于堆顶 加入               {               q.push(k);               q.pop(); //把堆顶换了               }           else break;           }       }   }   for(int i=1;i<=m;i++) //只取前m个   {ans[i]=q.top();   q.pop();   }   for(int i=m;i>=1;i--) //倒着输出 用的是大根堆   printf("%d ",ans[i]);}</code></pre><h2 id="P1983-车站分级">P1983 车站分级</h2><blockquote><p>这题没理解透测</p></blockquote><pre class=" language-language-c"><code class="language-language-c">#include<iostream>#include<stdio.h>#include<algorithm>#include<queue>#include<cstring>using namespace std;const int N=40000,M=40*N;queue<int>q;bool st[M];int h[N],ne[M],ver[M],e[M],idx,d[M],ans[M],num,dist[M];int n,m;void add(int x,int y,int z){    ver[++idx]=y,e[idx]=z,ne[idx]=h[x],h[x]=idx;    d[y]++;}void topsort(){    for(int i=1;i<=n+m;i++){        if(!d[i])q.push(i);    }    while(q.size()){        int x=q.front();q.pop();        ans[num++]=x;        for(int i=h[x];i;i=ne[i]){            int y=ver[i];            if(--d[y]==0)q.push(y);        }    }}int main(){    scanf("%d%d",&n,&m);    for(int i=1;i<=m;i++){        memset(st,0,sizeof st);        int t;    scanf("%d",&t);    int start=n,end=1;    while(t--){        int stop;        scanf("%d",&stop);        start=min(start,stop);        end=max(stop,end);        st[stop]=true;    }    int vtl=i+n;    for(int j=start;j<=end;j++)    if(st[j])add(vtl,j,1);    else add(j,vtl,0);    }    topsort();    for(int i=1;i<=n;i++)dist[i]=1;    for(int i=0;i<n+m;i++){        int y=ans[i];        for(int k=h[y];k;k=ne[k]){            int j=ver[k];            dist[j]=max(dist[j],dist[y]+e[k]);        }    }    int res=0;    for(int i=1;i<=n;i++)res=max(res,dist[i]);    printf("%d\n",res);}</code></pre><h2 id="P1078-文化之旅">P1078 文化之旅</h2><blockquote><p>dijkstra算法做些操作</p><p>在判断的时候增加一些东西</p></blockquote><pre class=" language-language-c"><code class="language-language-c">#include<iostream>#include<stdio.h>#include<algorithm>#include<map>#include<cstring>#include<queue>using namespace std;const int N=1010,M=N*10;int n,m,k,s,t;bool v[M];int c[M],a[N][N],d[M];int h[N],ne[M],ver[M],e[M],idx,pre[M]; //pre[i]存的是i这个国家 前面的国家  可以看成链表priority_queue<pair<int,int> >q;void add(int x,int y,int z){    ver[++idx]=y,e[idx]=z,ne[idx]=h[x],h[x]=idx;}bool judge(int u,int v){ //v是u的出边    int tep=u;    while(tep){  //如果        if(a[c[v]][c[tep]]!=0||c[v]==c[tep]) //出边和前面走过的国家 文化冲突        return false;        tep=pre[tep];//等于 前面走过的国家    }    return true; //都没有冲突 返回}void dijkstra(int st){    memset(d,0x3f,sizeof d);    memset(v,0,sizeof v);    d[st]=0;    q.push({0,1});    while(q.size()){        int x=q.top().second;q.pop();        if(v[x])continue;        v[x]=1;        for(int i=h[x];i;i=ne[i])        {            int y=ver[i],z=e[i];            if((d[y]>d[x]+z)&&judge(x,y)){  //修改1   增加判断                pre[y]=x;  //修改2 都没有冲突  那么存一下 y国家前面的走过的国家是x国                d[y]=d[x]+z;                q.push({-d[y],y});            }        }    }}int main(){    scanf("%d%d%d%d%d",&n,&k,&m,&s,&t);    for(int i=1;i<=n;i++)    scanf("%d",&c[i]);    for(int i=1;i<=k;i++)    for(int j=1;j<=k;j++)    scanf("%d",&a[i][j]);    for(int i=1;i<=m;i++){  //无向边两边都要加   int a,b,c;   scanf("%d%d%d",&a,&b,&c);   add(a,b,c);add(b,a,c);    }    dijkstra(s);   if(d[t]>0x3f3f3f3f/2) printf("-1");   else printf("%d",d[t]);}</code></pre><h2 id="P4981-父子">P4981 父子</h2><blockquote><p>这道题 我是看了题解才会的，一开始想的是生成树 那么多枝杈 怎么求</p><p>Cayley 公式： 对于n<em>n</em>个不同的节点，能够组成的<strong>无根树</strong>的种数是$$n^{n-2}$$种。</p><p>​           则：      对于n<em>n</em>个不同的节点， 能够组成的<strong>有根树</strong>的种数是$$n^{n-1}$$种。</p></blockquote><pre class=" language-language-c"><code class="language-language-c">const int Mod=1e9+9,N=10001;long long n;long long power(long long a,long long b,long long Mod){    long long ans=1%Mod;    while(b){        if(b&1)ans=ans*a%Mod;        a=a*a%Mod;        b>>=1;    }    return ans%Mod;}int main(){    int t;    scanf("%d",&t);    while(t--){    scanf("%lld",&n);    printf("%lld\n",power(n,n-1,Mod));    }}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 洛谷刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拓扑排序</title>
      <link href="/2020/082122315.html"/>
      <url>/2020/082122315.html</url>
      
        <content type="html"><![CDATA[<h1>拓扑序列</h1><blockquote><p>有向无环的图 具有拓扑序列</p><p>拓扑序列仅对有向图来说 无向图没有</p></blockquote><p>在介绍拓扑排序之前，我们还需要知道<code>度</code>的概念</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/Arbor334/img/algoirthm/topsort.png" alt=""></p><p>拓扑序列的流程</p><p>【1】、把所有入度为0的点 进队</p><p>【2】、取出队头，遍历队头指向的所有出边</p><p>【3】、删除队头，出边的入度 减 1</p><p>【4】、入度为0的边继续入队</p><p><a href="https://www.acwing.com/problem/content/description/850/" target="_blank" rel="noopener">Acwing练习题</a></p><pre class=" language-language-c"><code class="language-language-c">using namespace std;const int N=1000100;int ans[N],ver[N],ne[N],h[N],idx,n,m,a,b,d[N],num;queue<int>q;void add(int x,int y){    ver[++idx]=y,ne[idx]=h[x],h[x]=idx;}bool topsort(){    for(int i=1;i<=n;i++)    if(d[i]==0)q.push(i);    while(q.size()){        int x=q.front();q.pop();        ans[num++]=x;        for(int i=h[x];i;i=ne[i]){            int y=ver[i];            if(--d[y]==0) q.push(y);        }    }    return num==n;}int main(){    scanf("%d%d",&n,&m);    for(int i=1;i<=m;i++){        scanf("%d%d",&a,&b);        add(a,b);        d[b]++;    }    if(topsort())    { for(int i=0;i<num;i++)        printf("%d ",ans[i]);        puts("");    }else    puts("-1");}</code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 拓扑排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最短路</title>
      <link href="/2020/081819070.html"/>
      <url>/2020/081819070.html</url>
      
        <content type="html"><![CDATA[<h1>最短路</h1><p><a href="https://www.acwing.com/blog/content/27/" target="_blank" rel="noopener">参考自AcwingYxc</a></p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/Arbor334/img/algoirthm/shortroad.png" alt=""></p><h2 id="朴素的Dijkstra算法">朴素的Dijkstra算法</h2><blockquote><p>图用邻接矩阵存储     <code>时间复杂度O（n^2）</code></p><p>每次都找距离最近的点</p><p>只能处理边权为正数的问题</p></blockquote><pre class=" language-language-c"><code class="language-language-c">const int N=510,M=N*2;int a[M][M],d[M],n,m,x,y,z,start; //a 存邻接矩阵 d表示每个点到起点的距离bool v[M];void dijkstra(int start){    memset(d,0x3f,sizeof d);    memset(v,0,sizeof v);    d[start]=0;    for(int i=1;i<n;i++)//遍历n-1次    {        int x=0;        for(int j=1;j<=n;j++) //找到未遍历节点中dist值最小的        if(!v[j]&&(x==0||d[j]<d[x]))        x=j;        v[x]=1;//设置为遍历了        for(int y=1;y<=n;y++) //更新其他节点        d[y]=min(d[y],d[x]+a[x][y]); //这里是和prim算法不一样的地方    }}int main(){    scanf("&n,&m");    memset(a,0x3f,sizeof a); //使用邻接矩阵    for(int i=1;i<=n;i++)a[i][i]=0;    for(int i=1;i<=m;i++){        scanf("%d%d%d",&x,&y,&z);        a[x][y]=min(a[x][y],z);    }  start=1;    dijkstra(start);//这里默认第一个节点为起点    if(d[n]==0x3f3f3f3f)  printf("-1\n");    else   printf("%d ",d[n]);}</code></pre><h2 id="堆优化的Dijkstra算法">堆优化的Dijkstra算法</h2><blockquote><p>图用邻接表储存 <code>时间复杂度O（mlogn）</code>  n为节点数 m为边数</p><p>用堆维护所有点到起点的距离，</p><p>我们这里使用的是<code>priority_queue</code>中的大根堆</p><p>只能处理边权是正数的问题</p></blockquote><pre class=" language-language-c"><code class="language-language-c">const int N=150010,M=2*N;priority_queue<pair<int,int> >q;int e[M],idx,ver[N],h[N],ne[M],n,m,d[M];bool v[M];void add(int a,int b,int z){ //ver存的是点集 e存的边集    ver[++idx]=b,e[idx]=z,ne[idx]=h[a],h[a]=idx;}void dijkstra(){    memset(d,0x3f,sizeof(d));    memset(v,0,sizeof(v));    d[1]=0;//从第一个点出发    q.push({0,1}); //第一位存的d，第二位存的节点编号    while(q.size()){        int x=q.top().second;q.pop();//取出队顶存的第二位 节点，并且去除对顶        if(v[x]) continue;//如果已经访问过了        v[x]=1; //没访问过 就设定为访问        for(int i=h[x];i;i=ne[i]) //扫描所有的出点        {            int y=ver[i],z=e[i]; // y是节点，z是权值            if(d[y]>d[x]+z) //更新            d[y]=d[x]+z;            q.push({-d[y],y});//因为用的是大根堆，节点的值越大，变为负数越小 最后堆顶就是实际最短的距离        }    }}int main(){  scanf("%d%d",&n,&m);    for(int i=1;i<=m;i++){        int x,y,z;        scanf("%d%d%d",&x,&y,&z);        add(x,y,z);    }    dijkstra();    if(d[n]==0x3f3f3f3f)   printf("-1\n");    else    printf("%d",d[n]);}</code></pre><h2 id="Bellman-Ford-（BF）算法">Bellman-Ford （BF）算法</h2><blockquote><p>先进行n-1次迭代<br>接着枚举每条边<br>然后用以前的边更新这个边<br>需要用一个last数组存上次使用的点，需要<code>备份数组</code>。</p></blockquote><pre class=" language-language-c"><code class="language-language-c">const int N=100010;struct node{    int a,b,w;}e[N];int n,m,k;int backup[N],dist[N];int bf(){    memset(dist,0x3f,sizeof(dist));    dist[1]=0;    for(int i=1;i<=k;i++)    {  memcpy(backup,dist,sizeof(dist));//备份数据        for(int j=1;j<=m;j++)        {         int a=e[j].a,b=e[j].b,w=e[j].w;          dist[b]=min(dist[b],backup[a]+w);        }    }    if(dist[n]>0x3f3f3f3f/2) return -1;    else return dist[n];}int main(){    scanf("%d%d",&n,&m);    for(int i=1;i<=m;i++){        scanf("%d%d%d",&e[i].a,&e[i].b,&e[i].w);    }    int t=bf();    if(t==-1)printf("impossible");    else printf("%d",t);}</code></pre><h2 id="Spfa-算法">Spfa 算法</h2><blockquote><p>用邻接表存储</p><p>最坏的<code>时间复杂度是O（nm）</code> 期望<code>运行时间是O(km)</code> k是常数</p><p>是BF算法优化版本，可以处理存在<code>负边权</code>的最短路问题</p><p>在网格图中，spfa算法效率较低，边权都为正买最好使用Dijkstra</p></blockquote><pre class=" language-language-c"><code class="language-language-c">const int N=100010,M=N*2;int ne[M],e[N],var[M],h[N],n,m,idx,start;int x,y,z,d[M];bool v[M];queue<int>q;void add(int x,int y,int z){    var[++idx]=y,e[idx]=z,ne[idx]=h[x],h[x]=idx;}void spfa(int start){    memset(d,0x3f,sizeof(d));    memset(v,0,sizeof(v));    v[start]=1;d[start]=0;    q.push(start);    while(q.size()){        int x=q.front();q.pop();//取出队头      v[x]=0;        for(int i=h[x];i;i=ne[i]){ //扫描所有出边            int y=var[i],z=e[i];            if(d[y]>d[x]+z){ //更新，并将新的二元组插入队            d[y]=d[x]+z;            if(!v[y])q.push(y),v[y]=1;            }        }    }}int main(){   scanf("%d%d",&n,&m);    for(int i=1;i<=m;i++)    {        scanf("%d%d%d",&x,&y,&z);        add(x,y,z);    }  start=1; //默认是1位起点，有的是会告诉你 当xxx等于yy的时候 是起点    spfa(start);    if(d[n]==0x3f3f3f3f)    printf("impossible");    else  printf("%d",d[n]);}</code></pre><h2 id="Floyd算法">Floyd算法</h2><blockquote><p>标准弗洛伊德算法，三重循环。</p><p>循环结束之后 <code>d[i][j]</code>存储的就是点 <code>i</code>到点 <code>j</code> 的最短距离。<br>需要注意循环顺序不能变：第一层枚举中间点，第二层和第三层枚举起点和终点。</p><p>由于这道题目的数据范围较大，点数最多有1000个，因此floyd算法会超时。</p></blockquote><pre class=" language-language-c"><code class="language-language-c">const int N=1010;int n,m,t,x,y,z;int d[N][N];int main(){    scanf("%d%d%d",&n,&m,&t);    memset(d,0x3f,sizeof d);    for(int i=1;i<=n;i++) d[i][i]=0;    for(int i=1;i<=m;i++){        scanf("%d%d%d",&x,&y,&z);        d[x][y]=min(d[x][y],z);    }    for(int k=1;k<=n;k++)//中间点在第一层    for(int i=1;i<=n;i++)    for(int j=1;j<=n;j++){        d[i][j]=min(d[i][k]+d[k][j],d[i][j]);    }    while(t--){        cin>>x>>y;        if(d[x][y]>0x3f3f3f3f/2) printf("impossbile");        else printf("%d",d[x][y]);    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最短路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递归枚举</title>
      <link href="/2020/081725148.html"/>
      <url>/2020/081725148.html</url>
      
        <content type="html"><![CDATA[<h1>递归枚举</h1><h2 id="递归实现指数型枚举">递归实现指数型枚举</h2><p><a href="https://www.acwing.com/problem/content/description/94/" target="_blank" rel="noopener">Acwing题目链接</a></p><pre class=" language-language-c"><code class="language-language-c">const int N=16;vector<int> ch;int n;void dfs(int x){    if(x==n+1){        for(int i=0;i<ch.size();i++){            printf("%d ",ch[i]);        }        printf("\n");        return ;    }    dfs(x+1); \\不选这个数 进行递归    ch.push_back(x);\\选择了这个数      dfs(x+1); \\ 这个是选择了数进行递归      ch.pop_back(); \\排出去}int main(){    cin>>n;    dfs(1);//先选择1个的  注意  dfs x==n+1 会判别出空集  空集也是一个集合    return 0;}</code></pre><h2 id="递归实现组合型枚举">递归实现组合型枚举</h2><p><a href="https://www.acwing.com/problem/content/95/" target="_blank" rel="noopener">Acwing题目链接</a></p><pre class=" language-language-c"><code class="language-language-c">vector<int>ch;int n,m;void dfs(int x){ if(ch.size()>m||ch.size()+(n-x+1) `<` m)//判定一下 选出的不是m个就直接返回     return;    if(ch.size()==m)    { //等于m个 就输出        for(int i=0;i`<`ch.size();i++)        {            printf("%d ",ch[i]);        }        printf("\n");        return ;    }    ch.push_back(x); //选择x这个数    dfs(x+1);//再继续往下找    ch.pop_back();//拍出来    dfs(x+1);//把x排出去了，在往下找}int main(){    scanf("%d%d",&n,&m);    dfs(1);    return 0;}</code></pre><h2 id="递归实现排列型枚举">递归实现排列型枚举</h2><p><a href="https://www.acwing.com/problem/content/96/" target="_blank" rel="noopener">Acwing题目链接</a></p><pre class=" language-language-c"><code class="language-language-c">int n;const int N=20;int ch[N];bool st[N];void dfs(int x){     if(x==n+1){         for(int i=1;i<=n;i++){             printf("%d ",ch[i]);         }         printf("\n");     }   for(int i=1;i<=n;i++){       if(st[i])continue; //这个位置的数选了       st[i]=1; //没选过 该选了致1       ch[x]=i; //第x为 数i       dfs(x+1); //进行第x+1位       st[i]=0;       ch[x]=0;   }}int main(){    scanf("%d",&n);    dfs(1);    return 0;}</code></pre><h2 id="n-皇后问题">n-皇后问题</h2><p><a href="https://www.acwing.com/problem/content/description/845/" target="_blank" rel="noopener">Acwing题目链接</a></p><pre class=" language-language-c"><code class="language-language-c">//这种解法是按照全排列的顺序来做的using namespace std;const int N=20;char g[N][N];int n;bool dg[N],udg[N],col[N]; //dg 存的是由右上向左下方向的对角线 udg存的是 由左上向右下的对角线 col存的是列void dfs(int x){    if(x==n){ //拍好了以后 输出        for(int i=0;i `<` n;i++)puts(g[i]);        puts("");        return ;    }    for(int i=0;i<n;i++){        if(!col[i]&&!dg[x+i]&&!udg[n-x+i]){ //都没有皇后 才能放皇后        g[x][i]='Q'; //更新        col[i]=dg[x+i]=udg[n-x+i]=true; //更新        dfs(x+1);//更深一层          col[i]=dg[x+i]=udg[n-x+i]=false; //恢复现场          g[x][i]='.';    }    }}int main(){    scanf("%d",&n);    for(int i=0;i<n;i++) //初始化    for(int j=0;j<n;j++)    g[i][j]='.';    dfs(0);//从第0层开始排   实际中的第一层    return 0;}</code></pre><p>第二种解法</p><pre class=" language-language-c"><code class="language-language-c">const int N=20;char g[N][N];int n;bool dg[N],udg[N],col[N],row[N];void dfs(int x,int y,int s){ //x 行 y 列 s个    if(y==n)y=0,x++; //这一行    if(x==n){        if(s==n){        for(int i=0;i<n;i++)puts(g[i]);        puts("");      } return ;    }  //不放皇后    dfs(x,y+1,s);  //放皇后    if(!row[x]&&!col[y]&&!dg[x+y]&&!udg[x-y+n]){        row[x]=col[y]=dg[x+y]=udg[x-y+n]=true;        g[x][y]='Q';        dfs(x,y+1,s+1);         row[x]=col[y]=dg[x+y]=udg[x-y+n]=false;         g[x][y]='.';    }}int main(){    scanf("%d",&n);    for(int i=0;i<n;i++)    for(int j=0;j<n;j++)    g[i][j]='.';    dfs(0,0,0);    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图论</title>
      <link href="/2020/08179770.html"/>
      <url>/2020/08179770.html</url>
      
        <content type="html"><![CDATA[<h1>图论</h1><h2 id="孤立节点">孤立节点</h2><blockquote><p>不与任何节点相邻接的结点</p></blockquote><h2 id="零图">零图</h2><blockquote><p>仅由孤立节点构成的图</p></blockquote><h2 id="平凡图">平凡图</h2><blockquote><p>仅有一个孤立结点构成的图</p></blockquote><h2 id="邻接边">邻接边</h2><blockquote><p>关联于同一节点的两条边</p></blockquote><h2 id="自回路-环">自回路/环</h2><blockquote><p>关联于同一节点的一条边</p></blockquote><h2 id="度数">度数</h2><blockquote><p>与节点关联的边数，成为结点的度数</p></blockquote><h2 id="多重图">多重图</h2><blockquote><p>含有平行边的任何一个图</p></blockquote><h2 id="简单图">简单图</h2><blockquote><p>由无向图衍生出,一个结点对有且仅有一条边。</p></blockquote><h2 id="完全图Kp">完全图Kp</h2><blockquote><p>简单图G=&lt;V,E&gt;,每一对结点间都有边相连</p></blockquote><h2 id="Kn">Kn</h2><blockquote><p>有n个结点的无向完全图</p></blockquote><h2 id="补图">补图</h2><blockquote><p>给定一个图G,由G中所有结点和所有能使G成为完全图的添加边组成的图,称为G的相对于完全图的补图</p></blockquote><h2 id="生成子图">生成子图</h2><blockquote><p>若G的子图包含G的所有结点,该子图成为G的生成子图</p></blockquote><h2 id="相对补图">相对补图</h2><blockquote><p>设G’=&lt;V,E&gt;是G=&lt;V,E&gt;的子图,若给定另外一个图G’=&lt;V,E&gt;</p><p>使得E’’=E-E’,且V’’中仅包含E’’的边所关联的结点。则称G’’是子图G’的相对于图G的补图。</p></blockquote><h2 id="路-路径">路/路径</h2><blockquote><p>v0e1v1e2…envn称作连接vo到vn的路</p></blockquote><h2 id="回路">回路</h2><blockquote><p>路中,v0=vn时，就称作回路</p></blockquote><h2 id="简单路径">简单路径</h2><blockquote><p>一条路中所有<code>边</code> 均不相同</p></blockquote><h2 id="基本路径">基本路径</h2><blockquote><p>一条路中所有的<code>节点</code>不重复 <code>边</code>也不重复</p></blockquote><h2 id="连通">连通</h2><blockquote><p>两个节点之间存在一条路</p></blockquote><h2 id="连通图">连通图</h2><blockquote><p>图G只有一个分支</p></blockquote><h2 id="割集">割集</h2><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/Arbor334/img/Discretemath/geji.png" alt=""></p><h2 id="强联通">强联通</h2><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/Arbor334/img/Discretemath/youliantong.png" alt=""></p><h2 id="欧拉回路">欧拉回路</h2><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/Arbor334/img/Discretemath/oulahui.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最小生成树</title>
      <link href="/2020/081657313.html"/>
      <url>/2020/081657313.html</url>
      
        <content type="html"><![CDATA[<h1>最小生成树</h1><h2 id="克鲁斯卡尔算法">克鲁斯卡尔算法</h2><blockquote><p>文字来源 蓝书 【算法竞赛进阶指南】</p><p><code>Kruskal算法</code>总是维护<code>无向图的最小生成森林</code>。</p><p>最初可认为生成森林由0条边构成。每个节点各自构成一颗仅包含一个点的树。</p><p><code>时间复杂度为O(mlogm)</code></p></blockquote><h3 id="算法流程">算法流程:</h3><blockquote><p>【1】、建立并查集，每个点各自构成一个集合。</p><p>【2】、把所有边按照权值，从大到小排序，一次扫描每条边(x,y,z)</p><p>【3】、若x,y属于同一集合，则忽略这条边，继续扫描下一条</p><p>【4】、否则，合并x,y所在的集合，并把z累加到答案中</p><p>【5】、扫描完所有的边，第四部中处理过的边就构成最小生成树</p></blockquote><p><a href="https://www.luogu.com.cn/problem/P3366" target="_blank" rel="noopener">洛谷练习题</a></p><pre class=" language-language-c"><code class="language-language-c">const int N=5010,M=N*40;int fa[N],n,m,ans,k;struct rec{    int x,y,z;}e[M];bool cmp(rec a,rec b){return b.z>a.z;}int get(int x){    if(x==fa[x])return x;    return fa[x]=get(fa[x]);}int main(){    scanf("%d%d",&n,&m);    for(int i=1;i<=n;i++)fa[i]=i;    for(int i=1;i<=m;i++){        scanf("%d%d%d",&e[i].x,&e[i].y,&e[i].z);    }    sort(e+1,e+m,cmp);    for(int i=1;i<=m;i++){        int x=get(e[i].x);        int y=get(e[i].y);        if(x==y)continue;        fa[x]=y;        k++;        ans+=e[i].z;    }    if(k==n-1)    printf("%d\n",ans);    else printf("orz\n");}</code></pre><h2 id="Prim算法">Prim算法</h2><p><a href="https://www.acwing.com/problem/content/860/" target="_blank" rel="noopener">模板题木链接</a></p><blockquote><p>文字来源 蓝书 【算法竞赛进阶指南】</p><p>Prim算法总是<code>维护最小生成树的一部分</code></p><p><code>适用于稠密图，尤其是完全图的最小生成树的求解</code></p><p>最初，只确定1号节点属于最小生成树</p><p>任意时间，设已经确定属于最小生成树节点的集合为T<br>省余节点的集合为S</p><p>Prim找到 min x∈T，y∈S {z}</p><p>即：两个端点分别属于 S,T的权值的最小边，</p><p>把x从集合S 中删除，加入集合T中，并把 z 加入到答案中</p><p>维护数组d[], 若x∈S，d[x]表示节点x和节点T中的节点之间的权值的最小边。若x属于T，d[x]表示x被加入T是选出的最小边的权值</p><p><code>时间复杂度O(n^2)</code></p></blockquote><h2 id="prim算法流程">prim算法流程</h2><blockquote><p>【1】、先把数组d 赋值为正无穷</p><p>【2】、遍历n次 每次找到结合S中距离最近的点复制给 t</p><p>【3】、v[t]=true t边用过了</p><p>【4】、用 t 更新其他点到集合的距离</p></blockquote><h3 id="prim朴素算法代码">prim朴素算法代码</h3><pre class=" language-language-c"><code class="language-language-c">using namespace std;const int N=3010;int a[N][N],d[N],n,m,ans;bool v[N];void prim(){    memset(d,0x3f,sizeof d);    memset(v,0,sizeof v);    d[1]=0; //第一个点可以默认在T集合中    for(int i=1;i<n;i++){ //遍历n次        int x=0;        for(int j=1;j<=n;j++)        if(!v[j]&&(x==0||d[j]<d[x]))x=j; //找到最小权值            v[x]=1; //x这个最小权值边用过了            for(int y=1;y<=n;y++) //更新点到集合T的距离            if(!v[y])d[y]=min(d[y],a[x][y]);    }}int main(){    scanf("%d%d",&n,&m);    memset(a,0x3f,sizeof a); //用邻接矩阵存储 初始化都是不通的    for(int i=1;i<=n;i++) a[i][i]=0; //自己到自己为0    for(int i=1;i<=m;i++)    { int x,y,z;        scanf("%d%d%d",&x,&y,&z);        a[x][y]=a[y][x]=min(a[x][y],z); //无向图 所以 x->y y->x都要存    }    prim();    for(int i=2;i<=n;i++)ans+=d[i]; //d就是prim以后每次加如集合T的最小权值     if(ans>4990000) //(500-1)*10000     printf("impossible\n");    else    printf("%d\n",ans);}</code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最小生成树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分</title>
      <link href="/2020/081464018.html"/>
      <url>/2020/081464018.html</url>
      
        <content type="html"><![CDATA[<h1>二分</h1><h2 id="模板">模板</h2><p><a href="https://www.acwing.com/blog/content/31/" target="_blank" rel="noopener">模板链接</a></p><pre class=" language-language-c"><code class="language-language-c">二分模板一共有两个，分别适用于不同情况。算法思路：假设目标值在闭区间[l, r]中， 每次将区间长度缩小一半，当l = r时，我们就找到了目标值。版本1当我们将区间[l, r]划分成[l, mid]和[mid + 1, r]时，其更新操作是r = mid或者l = mid + 1;，计算mid时不需要加1。C++ 代码模板：int bsearch_1(int l, int r){    while (l < r)    {        int mid = l + r >> 1;        if (check(mid)) r = mid;        else l = mid + 1;    }    return l;}版本2当我们将区间[l, r]划分成[l, mid - 1]和[mid, r]时，其更新操作是r = mid - 1或者l = mid;，此时为了防止死循环，计算mid时需要加1。C++ 代码模板：int bsearch_2(int l, int r){    while (l < r)    {        int mid = l + r + 1 >> 1;        if (check(mid)) l = mid;        else r = mid - 1;    }    return l;}</code></pre><h2 id="一元三次方程">一元三次方程</h2><p><a href="https://www.luogu.com.cn/problem/P1024" target="_blank" rel="noopener">题目链接</a></p><p>【1】、暴力做法</p><pre class=" language-language-c"><code class="language-language-c">#include<iostream>#include<stdio.h>#include<algorithm>using namespace std;double a,b,c,d;double fc(double x){return  a*x*x*x+b*x*x+c*x+d;}int main(){scanf("%d%d%d%d",&a,&b,&c,&d);for(double i=-100;i<=100;i+=0.001){double j=i+0.001;double y1=fc(i);double y2=fc(j);if(y1>=0&&y2<=0||y1<=0&&y2>=0){   double ans=(i+j)/2;   printf("%.2lf ",ans);}}}</code></pre><p>【2】、二分做法</p><pre class=" language-language-c"><code class="language-language-c">#include<iostream>#include<stdio.h>#include<algorithm>using namespace std;double a,b,c,d,mid;int ans;double fc(double x){    return a*x*x*x+b*x*x+c*x+d;}int main(){scanf("%d%d%d%d",&a,&b,&c,&d);for(int i=-100;i<=100;i+=1){   //遍历区间    double l=i ,r=i+1;    double x1=fc(l);    double x2=fc(r);    if(!x1){ //如果x1是0  直接输出答案 l        printf("%.2lf ",l);        ans++;    }    if(x1*x2<0){  //两边异号有零点        while(r-l>=0.001){  //逐渐逼近零点            mid=(l+r)/2;            if(fc(mid)*fc(r)<0) // 如果中间点的值*右端点的值 <0 说明还能逼近零点            l=mid;            else            r=mid;        }        printf("%.2lf ",l);        ans++;    }    if(ans==3){//答案输出了三个就够了        break;    }}}</code></pre><h2 id="一元三次方根">一元三次方根</h2><p><a href="https://www.acwing.com/problem/content/description/792/" target="_blank" rel="noopener">Acwing题目链接</a></p><pre class=" language-language-c"><code class="language-language-c">#include<stdio.h>#include<algorithm>#include<iostream>using namespace std;double n;double get(double x){    return x*x*x;}int main(){    scanf("%d",&n);    double l=-10000,r=10000;    while(r-l>=1e-8){        double mid=(l+r)/2;        if(get(mid)<=n) l=mid;         else r=mid;    }    printf("%.6lf",l);}</code></pre><h2 id="数列分段">数列分段</h2><p><a href="https://www.luogu.com.cn/problem/P1182" target="_blank" rel="noopener">数列分段 Section II</a></p><pre class=" language-language-c"><code class="language-language-c">#include<iostream>#include<stdio.h>#include<algorithm>using namespace std;const int N=100100;int a[N],n,m,l,r,total,tim,mid;inline bool judge(int mid,int a[]){    for(int i=0;i<n;i++){        if(total+a[i]<=mid) total+=a[i];  //能加进去就加进去，        else total=a[i],tim++;       //不能加进去就分出来一个新的框框 并给框框数+1    }    return tim>=m; //判断框框数和要分的框框数的关系}int main(){    scanf("%d%d",&n,&m);    for(int i=0;i<n;i++){        scanf("%d",&a[i]);        r+=a[i];        //右端点是总和        l=max(a[i],l); //左端点是数列中的最大值    }     while(l<=r){        //分成 [l,mid-1],[mid+1,r]         mid=(l+r)/2;        total=0,tim=0;    //每次都要更新 total 和tim        if(judge(mid,a))l=mid+1;        else r=mid-1;     }    printf("%d",l);}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二次探测定理</title>
      <link href="/2020/081461991.html"/>
      <url>/2020/081461991.html</url>
      
        <content type="html"><![CDATA[<h1>二次探测定理</h1><h2 id="定理">定理</h2><blockquote><p>如果p为一个质数，则 x^2≡1（mod）p的解为</p><p>x1=1,x2=p-1</p></blockquote><h2 id="证明">证明</h2><p>$$<br>x^2≡1（mod）p→x^2-1=0（mod）p→（x-1）×（x+1）=0（mod）p→<br>p|（x-1）×（x+1）<br>$$</p><p>由p为一个质数可以推出x1=1,x2=p-1</p>]]></content>
      
      
      
        <tags>
            
            <tag> 二次探测定理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>费马小定理</title>
      <link href="/2020/081419332.html"/>
      <url>/2020/081419332.html</url>
      
        <content type="html"><![CDATA[<h2 id="乘法逆元">乘法逆元</h2><blockquote><p>加法 减法 乘法 满足分配率  而 除法不满足</p></blockquote><p>(a+b)%p=(a%p+b%p)%p  √</p><p>(a-b)%p=(a%p-b%p)%p        √</p><p>(a×b)%p=(a%p×b%p)%p       √</p><p>(a/b)%p=(a%p/b%p)%p          ×</p><h3 id="定义-：">定义 ：</h3><blockquote><p>若在 mod p意义下，对于一个整数a，有a×x≡1(mod p)  那么x就是a的乘法逆元，同时a也是x的乘法逆元</p><p>同余式<code>≡</code> ：a≡b(mod)p表示 a和b对p取模同余，及正整数a-b   能被p整除</p><blockquote><p>很简单   设 a=19  b=10  p=3</p><p>​                  a(mod)p=1              ①</p><p>​                   b(mod)p=1            ②</p><p>​                    (a-b)(mod)p=0      因为 ①中的a 也剪掉了② b中的 余数 1啊</p></blockquote></blockquote><h3 id="充要条件">充要条件</h3><blockquote><p>a存在模p的乘法逆元的充要条件是gcd(a,p)=1 ，即a与p互质 <s>这里先留出来空地 补上gcd</s></p></blockquote><h3 id="应用">应用</h3><p><a href="https://www.acwing.com/problem/content/description/878/" target="_blank" rel="noopener">Acwing题目链接:求逆元</a></p><blockquote><p>求取(a/b)%p等同于 a×(b的逆元)%p</p><p>我们不妨设b的逆元是 x    即   <code>b × x ≡ 1 （mod）p</code>   x= 1/b</p><p>那么                                  <code>(a/b)%p     ——&gt;  (a × x)  %p</code></p><p>​    <code>证明 </code></p><blockquote><p>设     (a/b)%p= m                                ①</p><p>① 两边都乘以b    -&gt;   a%p≡ m*b%p    ②</p><p>②两边都乘以上面的x  -&gt;  a × x ≡ m × b × x</p><p>​                                           a × x ≡ m</p></blockquote><p>上面已经证明了 这样做是正确的</p><p>但是 怎么求b的逆元，即 怎么求x呢？</p><p>这就是下面要讲的费马小定理</p></blockquote><h2 id="费马小定理（p为质数）">费马小定理（p为质数）</h2><h3 id="定义">定义</h3><p>假如a是一个整数，p是一个质数，那么</p><p>1、如果a是p的倍数，a^p≡a(mod)p<br>$$<br>a^{p-1} ==  a^p -a<br>$$</p><blockquote><p>a又是p的倍数  所以有</p></blockquote><p>$$<br>(a^p-a)(mod)p ==0  &gt;&gt;a^p(mod)p=a(mod)p &gt;&gt;a^p≡a(mod)p<br>$$</p><p>2、如果a不是p的倍数  a^(p-1)≡1(mod)p<br>$$<br>a^{p-1}≡ 1 (mod)p &gt;&gt; a×a^{p-2}≡1(mod)p<br>$$</p><blockquote><p>对比一下  a × x ≡1（mod）p</p></blockquote><p>那么 是不是 a^(p-2)就是a的逆元了呢？  <code>并不是</code><br>$$<br>a×a^{p-2}≡1(mod)p写成等式应该是 a(mod)p×((a^{p-2})(mod)p)=1(mod)p<br>$$<br>所以真正的逆元值为<br>$$<br>(a^{p-2})(mod)p<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 费马小定理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>质数</title>
      <link href="/2020/081416648.html"/>
      <url>/2020/081416648.html</url>
      
        <content type="html"><![CDATA[<h1>质数</h1><h2 id="1、定义">1、定义</h2><blockquote><p>若一个正整数无法被除了1和他自身之外的任何自然数整除，则称该数为质数（也叫素数）否则成这个数为合数</p><p><code>0和1 既不是质数也不是合数</code></p></blockquote><ul><li>在整个自然数集中，质数的数量不多，分布比较稀疏，对于一个足够大的整数N，不超过N的质数大约有N/lgN个，即每lgN中大约只有一个质数</li></ul><h2 id="2、质数的判定">2、质数的判定</h2><h3 id="【1】、试除法">【1】、试除法</h3><p><a href="https://www.acwing.com/problem/content/868/" target="_blank" rel="noopener">Acwing题目链接</a></p><p><code>时间复杂度为O(根号N)</code></p><pre class=" language-language-cpp"><code class="language-language-cpp">#include<cmath>bool is_prime(int n){   if(n<2) return false;  for(int i=2;i<=sqrt(n);i++)       if(n%i==0)       return false;  return true;                      //返回true  说明 n 是质数}</code></pre><h2 id="3、质数的筛选">3、质数的筛选</h2><blockquote><p>给定一个整数N，求出1~N之间的所有质数，就是质数的筛选问题</p></blockquote><h3 id="1-、埃拉托色尼筛选法（Eratosthenes）">[1]、埃拉托色尼筛选法（Eratosthenes）</h3><p><a href="https://www.acwing.com/problem/content/description/870/" target="_blank" rel="noopener">Acwing题目链接</a></p><blockquote><p>埃拉托色尼筛法基于这样的思想，任意整数x的倍数 2x,3x… 都不是质数</p><p>我们可以从2开始，由小到大扫描每个数x，把它的倍数2x,3x,.[N/x]*x标记为合数。</p><p>当扫描到一个数时，若他尚未被标记，则它不能被2~x-1之间的任何数整除，该数就是质数。</p></blockquote><ul><li>【1】、小于x^2的 x的倍数在扫描更小的数的时候已经标记过了。所以我们对于每个数x，只需要从x^2开始  把x^2，(x+1)乘x ,…  [N/x]乘x标记为合数即可</li></ul><p>$$<br>筛法的时间复杂度为  O(\sum质数p\leq N\frac{N}{p})=O(NloglogN)<br>$$</p><pre class=" language-language-cpp"><code class="language-language-cpp">int primes[N],cnt;bool v[N];void primes(int n){  memset(v,0,sizeof v);  for(int i=2;i<=n;i++)  {    if(v[i]) continue;    primes[cnt++]=i; //存到数组里去    for(int j=i+i;j<=n;j+=i) v[j]=true; //【1】、   }}</code></pre><h3 id="【2】、线性筛法">【2】、线性筛法</h3><p><a href="https://www.acwing.com/problem/content/description/870/" target="_blank" rel="noopener">Acwing题目链接</a></p><ul><li><p>核心：n 只会被自己的最小质因子筛掉</p><blockquote><p>埃拉托色尼筛法 有的时候实惠重复标记合数。</p><p>线性筛法通过<code>从小到大累积质因子</code>的方式标记每个合数，让一个合数 只能从 最小质因子的乘积得出。</p><p>【1】、依次考虑2~N之间的数</p><p>【2】、若v[i]=true，说明它的最小质因子已经把它筛掉了，反之，就加入到primes数组中</p><p>【3】、扫描不大于n/i的每个质数  令v[primes[j]*i]=true</p><blockquote><p>为什么要v[primes[j]*i]=true呢 ?</p><p>[1]、 i%primes[j]==0 说明primes[j]是i的最小质因子，那么primes[j]也一定是primes[j]*i 的最小质因子</p><p>[2]、i %primes[j]!=0  由于我们是从小到大枚举的，并且没有枚举到i的质因子，所以 primes[j] 一定小于i的所有质因子，  primes[j]也一定是primes[j]*i 的最小质因子</p></blockquote></blockquote></li></ul><p><code>时间复杂度O(n)</code></p><pre class=" language-language-cpp"><code class="language-language-cpp">int primes[N],cnt;bool v[N];void get_primes(int n){for(int i=2;i<=n;i++){  if(!v[i])primes[cnt++]=i;//没有筛掉就是质数  for(int j=0;primes[j]<=n/i;j++){ //从小到大枚举质数     v[primes[j]*i]=true; //每次把质数和i的乘积筛掉  保留的是合数  即 v[i]=0 是质数  v[i]=1是合数      if(i%primes[j]==0) break;//primes[j]一定是i的最小质因子    }}}</code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LCA</title>
      <link href="/2020/081355088.html"/>
      <url>/2020/081355088.html</url>
      
        <content type="html"><![CDATA[<h1>最近公共祖先（LCA）</h1><h2 id="哲学三问">哲学三问</h2><h3 id="1、what-？（-LCA是什么）">1、what ？（ LCA是什么）</h3><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/Arbor334/img/algorithm/LCA.png" alt=""></p><blockquote><p>Least Common Ancestors （LCA 最近公共祖先）</p><p>如上图所示 ，在X Y的所有公共祖先中，深度最大的一个称为x,y的最近公共祖先，即LCA(X,Y)</p><p>LCA(X,Y) 是x到根节点与y到根节点的路径的交汇点。它也是x和y之间路径上深度最小的节点</p></blockquote><h3 id="2、why-（为什么学习LCA）">2、why?（为什么学习LCA）</h3><blockquote><p><s>为了增长见识</s> 还不就是要多拥有点思路，武器在手，啥题目都逃不过<s>火眼金睛</s> 脑子。</p></blockquote><h3 id="3、how？-（怎么解决LCA问题）">3、how？ （怎么解决LCA问题）</h3><h4 id="向上标记法">向上标记法</h4><blockquote><p>向上标记法过程：</p><p>【1】、从x节点出发，走向根节点，并标记所有经过的节点</p><p>【2】、从y节点出发，走向根节点，当<code>第一次</code>遇到了已经标记了的节点（x走过了的），就找到了LCA(X,Y)</p><p>【3】、每次询问，注意是每次， 向上标记法的时间复杂度最坏是<code>O(N)</code></p><p>这里就不给出代码了 是因为我不会写么<s>是的</s> 主要还是怕写出来不对 = =！！</p></blockquote><h4 id="树上倍增法">树上倍增法</h4><p><a href="https://www.acwing.com/blog/content/2145/" target="_blank" rel="noopener">引用链接</a></p><p>设 F[x，k]是x的第2^k 辈祖先，向根节点走2^k步到的节点。</p><p>如果走了2^K步，发现节点不存在，F[x,k]=0；</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/Arbor334/img/algorithm/lcatree.png" alt=""></p><blockquote><p>并且k 满足下面的表达式</p></blockquote><p>$$<br>∀ k\in(1,log(n))<br>$$</p><blockquote><p><code>预处理:  时间复杂度 是O(nlogn)</code></p><p>通过预处理计算出 树的每个节点的F[]，和深度数组 d[]，通过BFS按照层次顺序，在节点入队之前，计算出它在F[]中对应的值</p></blockquote><pre class=" language-language-c++"><code class="language-language-c++">queue<int>q;void bfs(int root){memset(d,0x3f,sizeof d);  d[0]=0;d[root]=1;       //根节点的深度是1  d[0]是哨兵等会会说  q.push(root);  while(q.size()){    int x=q.front();    q.pop();    for(int i=h[x];i;i=ne[i]){     int y=e[i];      if(d[y]>d[x]+1){        d[y]=d[x]+1;        f[y][0]=x;        for(int j=1;j<=t;j++) //这里的t是最大深度(int)(log(n)/logg(2))+1          f[y][j]=f[f[y][j-1]][j-1]; //上面的式子        q.push(y);      }    }  }}</code></pre><ul><li>基于F[]计算LCA(X,Y)</li></ul><p>每次询问的<code>时间复杂度是O(logn)</code><s>我觉得是因为往上跳</s></p><p>【1】、设d[x]表示x的深度，d[x]≥d[y]（否则可交换x,y)</p><p>【2】、用二进制拆分思想，把x向上调整到与y同一个深度</p><p>依次尝试从x向上走k=2^logn,…  2^1 , 2^0步，每次尝试中，检查到达节点是不是比y深，若是让 x=F[x,k]</p><p>【3】、若此时x=y，说明找到了LCA LCA就是y  上图最后一种</p><p>【4】、用二进制拆分思想，把x,y,同时向上调整，并保持深度一致且二者不相会。</p><p>依次尝试从x向上走k=2^logn,…  2^1 , 2^0步，每次尝试中，若F[x,k]≠F[y,k]（就是还没有相会），令x=F[x,k]=F[y,k]</p><p>【5】、此时 x, y 必定只差一步就相会了，它们的父节点 F[x, 0] 就是最近公共祖先。</p><blockquote><p><code>时间复杂度 O((n+m)logn)</code></p></blockquote><pre class=" language-language-cpp"><code class="language-language-cpp">queue<int>q;void bfs(int root){memset(d,0x3f,sizeof d);  d[0]=0;d[root]=1;       //根节点的深度是1  d[0]是哨兵等会会说  q.push(root);  while(q.size()){    int x=q.front();    q.pop();    for(int i=h[x];i;i=ne[i]){     int y=e[i];      if(d[y]>d[x]+1){        d[y]=d[x]+1;        f[y][0]=x;        for(int j=1;j<=t;j++) //这里的t是最大深度(int)(log(n)/logg(2))+1          f[y][j]=f[f[y][j-1]][j-1]; //上面的式子        q.push(y);      }    }  }}</code></pre><h5 id="例题">例题</h5><p><a href="https://www.acwing.com/solution/content/15678/" target="_blank" rel="noopener">Acwing 祖孙询问</a></p><blockquote><p><strong>【问题描述】</strong></p><p>​    已知一棵n个节点的有根树。有m个询问。每个询问给出了一对节点的编号x和y，询问x与y的祖孙关系。</p><p><strong>【输入格式】</strong></p><p>​    输入第一行包括一个整数n表示节点个数。</p><p>​    接下来n行每行一对整数对a和b表示a和b之间有连边。如果b是-1，那么a就是树的根。</p><p>​    第n+2行是一个整数m表示询问个数。</p><p>​    接下来m行，每行两个正整数x和y。</p><p><strong>【输出格式】</strong></p><p>​    对于每一个询问，输出1:如果x是y的祖先，输出2:如果y是x的祖先，否则输出0。</p><p><strong>【样例输入】</strong></p><pre class=" language-language-c"><code class="language-language-c">10234 -112 23413 23414 23415 23416 23417 23418 23419 234233 195234 233233 12233 13233 15233 19</code></pre><p><strong>【样例输出】</strong></p><pre class=" language-language-c"><code class="language-language-c">10002</code></pre><p><strong>【数据规模】</strong></p><p>​    对于30%的数据，n,m≤1000。</p><p>​    对于100%的.据,n,m≤40000，每个节点的编号都不超过40000。</p></blockquote><pre class=" language-language-cpp"><code class="language-language-cpp">#include<iostream>#include<stdio.h>#include<cstring>#include<algorithm>#include<queue>using namespace std;const int N = 40010, M = N * 2;   // 往上蹦  最大深度是 （int）(log(n)/log(2))+1   这就是15的由来int n, m;int h[N], var[M], ne[M], idx, d[M], f[M][16];queue<int>q;void add(int x, int y) {    var[++idx] = y, ne[idx] = h[x], h[x] = idx;}void  bfs(int root) {    memset(d, 0x3f, sizeof d);    d[0] = 0, d[root] = 1;    q.push(root);    while (q.size()) {        int x = q.front();        q.pop();        for (int i = h[x]; ~i; i = ne[i]) {            int y = var[i];            if (d[y] > d[x] + 1) {                d[y] = d[x] + 1;                q.push(y);                f[y][0] = x;                for (int k = 1; k <= 15; k++)                {                    f[y][k] = f[f[y][k - 1]][k - 1];                }            }        }    }}int lca(int a, int b) {    if (d[a] > d[b])swap(a, b);    for (int k = 15; k >= 0; k--) {        if (d[f[b][k]] >= d[a])            b = f[b][k];    }    if (a == b)return a;    for (int k = 15; k >= 0; k--) {        if (f[a][k] != f[b][k]) {            a = f[a][k];            b = f[b][k];        }    }    return f[a][0];}int main() {    int a, b;    int root = 0;    memset(h, -1, sizeof(h));    cin >> n;    for (int i = 1; i <=n; i++)    {        cin >> a >> b;        if (b == -1)root = a;        add(a, b);        add(b, a);    }    bfs(root);    cin >> m;    while (m--) {        cin >> a >> b;        int p = lca(a, b);        if (p == a)puts("1");        else if (p == b)puts("2");        else            cout << 0 << endl;    }}</code></pre><h4 id="Tarjan算法">Tarjan算法</h4><blockquote><p>【来自算法竞赛指南】</p><p>时间复杂度：O(n+m)</p><p>tarjan 算法本质上是使用并查集对 “向上标记法” 的优化。它是一个离线算法，需要把 m 个询问一次性读入，统一计算，最后统一输出。</p><p>在深度优先遍历的任意时刻，树中节点分为三类：</p><p>【1】、已经访问完毕并且回溯的节点。在这些节点上标记一个整数 2。</p><p>【2】、已经开始递归，但尚未回溯的节点。这些节点就是当前正在访问的节点 x 以及 x 的祖先。在这些节点上标记一个整数 1。</p><p>【3】、尚未访问的节点。这些节点没有标记。</p><p>对于正在访问的节点 x，它到根节点的路径已经标记为 1 。若 y 是已经访问完毕并且回溯的节点                     （被标记了 2），则 LCA(x， y)就是从 y 向上走到根，第一个遇到的标记为 1 的节点。</p><p>可以利用并查集进行优化，当一个节点获得整数 2 的标记时，把它所在的集合合并到它的父节点所在的集合中(合并时它的父节点标记一定为 1，且单独构成一个集合)。</p><p>这相当于每个完成回溯的节点都有一个指针指向它的父节点，只需查询 y 所在集合的代表元素，就等价于从 y 向上一直走到一个开始递归但尚未回溯的节点(具有标记 1)，即 LCA(x, y)。</p></blockquote><h5 id="例题-2">例题</h5><p><a href="https://www.acwing.com/problem/content/description/1173/" target="_blank" rel="noopener">ACwing题目链接</a></p><pre class=" language-language-c"><code class="language-language-c">给出 n 个点的一棵树，多次询问两点之间的最短距离。注意：边是无向的。所有节点的编号是 1,2,…,n。输入格式第一行为两个整数 n 和 m。n 表示点数，m 表示询问次数；下来 n−1 行，每行三个整数 x,y,k，表示点 x 和点 y 之间存在一条边长度为 k；再接下来 m 行，每行两个整数 x,y，表示询问点 x 到点 y 的最短距离。树中结点编号从 1 到 n。输出格式共 m 行，对于每次询问，输出一行询问结果。数据范围2≤n≤104,1≤m≤2×104,0<k≤100,1≤x,y≤n输入样例1：2 21 2 1001 22 1输出样例1：100100输入样例2：3 21 2 103 1 151 23 2输出样例2：1025</code></pre><pre class=" language-language-cpp"><code class="language-language-cpp">#include<stdio.h>#include<algorithm>#include<iostream>#include<vector>using namespace std;const int N = 2e4 + 10, M = 2 * N;int h[N], ne[M], e[M], ver[M], idx;int f[N], T, n, m, t;int d[N], v[N], lca[N], ans[N];vector<int> query[N], queryid[N];void add(int x, int y, int z) {    ver[++idx] = y, e[idx] = z, ne[idx] = h[x], h[x] = idx;}void addquery(int x, int y, int id) {  //    query[x].push_back(y), queryid[x].push_back(id);    query[y].push_back(x), queryid[y].push_back(id);}int get(int x) {    if (x == f[x])return x;    return f[x] = get(f[x]);}void tarjan(int x) {    v[x] = 1;//正在访问 还没有回溯    for (int i = h[x]; i; i = ne[i]) {        int y = ver[i];        if (v[y])continue;        d[y] = d[x] + e[i]; //  因为y是x的子节点， 到根节点的距离 就是 x到根节点的距离+e(x,y)        tarjan(y);//去以y为根节点的子树搜搜        f[y] = x;    }    for (int i = 0; i < query[x].size(); i++) {        int y = query[x][i], id = queryid[x][i];//取出信息        if (v[y] == 2) { //如果这个节点访问完，并且回溯了            int lca = get(y);  // 这个就是lca（x，y）            ans[id] = min(ans[id], d[x] + d[y] - 2 * d[lca]); //计算距离        }    }    v[x] = 2;//访问完了 回溯了}int main() {        scanf("%d%d",&n,&m);        for (int i = 1; i <= n; i++) //初始化        {            f[i] = i, h[i] = 0, v[i] = 0;            query[i].clear(), queryid[i].clear();        }        idx = 0;        for (int i = 1; i < n; i++)        {            int a, b, c;          scanf("%d%d%d",&a,&b,&c);            add(a, b, c), add(b, a, c);        }        for (int i = 1; i <= m; i++) {            int x, y;            scanf("%d%d",&x,&y);            if (x == y)ans[i] = 0; //如果x==y 直接赋值0            else {                addquery(x, y, i);  //信息添加                ans[i] = 1 << 18; //设置一个很大的值            }        }        tarjan(1);//从根节点开始遍历        for (int i = 1; i <= m; i++)          printf("%d\n",a[i]);}</code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LCA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>页内链接</title>
      <link href="/2020/081360887.html"/>
      <url>/2020/081360887.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>使用 <code>-[你自己可以取名字](#标题名字)</code><br>比如说  你可以取的名字是 点击  想要跳转到页内的 二级标题名为 arbor<br>那么 应该写成<code> -[点击](# arbor)</code><br>无论是 h1~h6标题 (都只有一个#)</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>background</title>
      <link href="/2020/081317546.html"/>
      <url>/2020/081317546.html</url>
      
        <content type="html"><![CDATA[<h2 id="修改背景">修改背景</h2><blockquote><p>我的主题是Matery</p><p>找到 themes\Matery\source\css\matery.css</p><p>搜索(ctrl+F)找到  body</p><p>修改为如下样式</p></blockquote><pre class=" language-language-css"><code class="language-language-css">body {    /* background-color: #eaeaea; */    background: linear-gradient(60deg, rgba(255, 165, 150, 0.5) 5%, rgba(0, 228, 255, 0.35)) 0% 0% / cover, url(""), url("") 0px 0px;// url 中最好是添加在网上有的图片弄到自己的图床上    background-attachment: fixed;    margin: 0;    color: #7F95D1;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树的直径</title>
      <link href="/2020/081227720.html"/>
      <url>/2020/081227720.html</url>
      
        <content type="html"><![CDATA[<h1>树的直径</h1><p><a href="https://www.luogu.com.cn/problem/U81904" target="_blank" rel="noopener">模板题目链接</a></p><h2 id="哲学三问">哲学三问</h2><ul><li>【1】、what ?  (什么是树的直径 )</li></ul><blockquote><p>简单来说，树上的任意两点之间的最长距离就是树的直径</p></blockquote><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/Arbor334/img/algorithm/longest_path_of_tree.jpg" alt=""></p><ul><li>【2】、why ？（为什么学习这个东西）</li></ul><blockquote><p><s>提高自己的算法能力</s>  出题会遇到，遇到了就要解决，不解决就会丢分</p></blockquote><ul><li>【3】、how ？ （怎么实现）</li></ul><blockquote><p>第一种方案 Dp：</p><blockquote><p>优点：可以处理负权边的问题</p><p>缺点：记录卡路径的信息效率低</p><p>实现过程：</p><p>我们假设一号节点为根，“N个点N-1条边的无向图”可以看成有根树。</p><p>设d[x]表示从节点x出发走向以x为根的子树，能够到达的最远节点的距离。</p><p>设x的子节点为y1,y2,y3…, e(x,y)表示边权有</p><p>d[x]=max(d[yi]+e(x,y))</p><p>考虑对每个点x 求出经过x节点的最长链的长度F[x]，</p><p>直径就是max 1≤x≤n（F[x]）</p><p>求 F[x]: 对于x的任意两个节点 yi和yj 经过节点x的最长链的长度分四个部分： 边 (x,yi) 边 (x,yj)  yi到yi子树的最远距离 yj到yj子树的最远距离</p><p>F[x]=max（d[yi]+d[yj]+e(x,yi)+e(x,yj)）</p><p>因为子节点将要循环到i时，d[x]存的就是从节点x出发走向</p><p>以 yj（j&lt;i）为根的子树能够到达的最远节点的距离， 就是</p><p>max（d[yj]+e(x,yj)）</p><p>我们先用 d[x]+d[yi]+e(x,yi)更新F[x]，</p><p>再用d[yi]+e(x,yi) 更新d[x]</p></blockquote><p>第二种方案 ：两次bfs</p><blockquote><p>优点：可以通过一个新的数组记录路径信息</p><p>缺点：无法处理负边权</p><p>实现流程：</p><p>【1】、从任意节点出发，通过BFS对树进行一次遍历求出与出发点距离最远的节点,记为 p</p><p>【2】、从节点 p 出发,通过 BFS 再进行一次遍历,求出与 p 距离最远的节点,记为 q。</p><p>p 是一个节点的最远的一个端点，那么从 p 出发的最远的端点就是直径的另一个端点)</p></blockquote></blockquote><h2 id="第一种解决方案-Dp">第一种解决方案 Dp</h2><pre class=" language-language-c++"><code class="language-language-c++">#include<iostream>#include<stdio.h>#include<algorithm>using namespace std;const int N=5e6+10,M=2*N;int h[N],ver[N],ne[M],e[M],idx;bool st[N];int d[N],ans,n,x,y,z;void add(int x,int y,int z){    ver[++idx]=y,e[idx]=z,ne[idx]=h[x],h[x]=idx;}void dp(int x){    st[x]=1;    for(int i=h[x];i;i=ne[i]){        int y=ver[i];        if(st[y])continue; //判断是否已经经过该节点        dp(y); //继续向下寻找子节点        ans=max(ans,d[x]+d[y]+e[i]); //枚举从x节点出发的所有边，找到最远的内个        d[x]=max(d[x],d[y]+e[i]);//经过枚举后 d[x]就不一定是最长的了，要更新一下    }}int main(){    cin>>n;    for(int i=0;i<n-1;i++)    {        cin>>x>>y>>z;        add(x,y,z);        add(y,x,z);    }    dp(1);    printf("%d\n",ans);}</code></pre><h2 id="第二种解决方案-bfs">第二种解决方案 bfs</h2><pre class=" language-language-c++"><code class="language-language-c++">#include<iostream>#include<stdio.h>#include<cstring>#include<queue>#include<algorithm>using namespace std;const int N=1e6+10;int h[N],dist[N],ne[N*2],e[N*2],idx,ver[N*2];int n,p,q,d,maxd;bool st[N];void add(int a,int b,int c){    ver[++idx]=b,e[idx]=c,ne[idx]=h[a],h[a]=idx;}int bfs(int u){    queue<int>q;    while(!q.empty())q.pop(); //注意每次都要清空    memset(st,0,sizeof st);    memset(dist,0,sizeof dist);    q.push(u);              //把根节点推进去    int x,max_num=0;       //max_num 找到最远的节点    while(!q.empty()){        x=q.front();      //取出队首        q.pop();          //抛出队首        st[x]=1;       // 这个点我走过了        for(int i=h[x];i;i=ne[i]){            int y=ver[i];    //子节点            if(st[y])continue;            st[y]=1;         //没走过 就修改为走过            dist[y]=dist[x]+e[i];  //从上往下走 就要进行累加 和dp不同            if(dist[y]>maxd){   //更新最大值 和最远点                maxd=dist[y];                max_num=y;            }            q.push(y);  // 每个新的节点都要加入到队列中,有可能与该节点相连的路径是比较长的        }    }    return max_num;  //返回最远的点}int main(){    scanf("%d",&n);    for(int i=1;i<n;i++){        cin>>p>>q>>d;        add(p,q,d);        add(q,p,d);    }    int u=bfs(1);    int s=bfs(u);//   printf("第一次遍历得到的节点 : %d\n",u);//     printf("第二次遍历得到的节点 : %d\n",s);//     printf("最长的距离是 %d\n",maxd);    printf("%d\n",maxd);    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树的直径 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown</title>
      <link href="/2020/081217683.html"/>
      <url>/2020/081217683.html</url>
      
        <content type="html"><![CDATA[<h1>标题</h1><p>井号 “#” 加 一个空格&quot; &quot;</p><p>一直可以到6级标题</p><h2 id="字体">字体</h2><p><strong>hello，world</strong>    变成粗体 两边各加两个*号</p><p><em>hello,world</em>     变成斜体 两边各加一个*号</p><p><em><strong>hello,world</strong></em>   加粗斜体 两边各加上 ***号</p><p><s>hello,world</s>     两边各加上两个波浪号</p><h2 id="引用">引用</h2><blockquote><p>大于号 + 空格</p></blockquote><h2 id="分割线">分割线</h2><hr><p>“—” 三个杠 就可以</p><hr><p>&quot;***&quot;三个星也可以</p><h2 id="图片">图片</h2><p><code>![名字](路径)</code></p><h2 id="超链接">超链接</h2><hr><p><a href="https://www.cnblogs.com/" target="_blank" rel="noopener">点击进入我的博客</a></p><blockquote><p>[名字]  (链接地址)</p></blockquote><h2 id="列表">列表</h2><hr><ol><li><p>A</p></li><li><p>B</p></li><li><p>C</p><blockquote><p>“1.空格”</p></blockquote></li></ol><ul><li>A</li><li>B</li><li>C</li></ul><blockquote><p>&quot;减号   空格  出来小点  &quot;</p></blockquote><h2 id="表格">表格</h2><hr><table><thead><tr><th>名字</th><th>性别</th><th>生日</th></tr></thead><tbody><tr><td>张三</td><td>男</td><td>1990.1.1</td></tr></tbody></table><h2 id="代码">代码</h2><pre class=" language-language-java"><code class="language-language-java">public static int main（String args[]）</code></pre><blockquote><p><strong>&quot;``` &quot;</strong>  然后加入 代码的名字  c c++  Java</p></blockquote><h2 id="数学公式">数学公式</h2><p>输入  &quot;$$ &quot; 然后回车会出现一个编辑框  按照下面的操作写就行了</p><p><a href="https://www.jianshu.com/p/cf36c5af997a" target="_blank" rel="noopener">下方引用博客链接</a></p><h4 id="1-上标和下标">1.上标和下标</h4><ul><li>下标使用符号<code>Y_1</code>表达,公式表达结果为: <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://math.jianshu.com/math?formula=y_1" alt="y_1"></li><li>上标使用 <code>X^{2m}</code>或者<code>X^2</code>, 其中较为复杂的表达式用<code>{}</code>包含, 公式表达结果为: <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://math.jianshu.com/math?formula=X%5E%7B2m%7D%2BX%5E2" alt="X^{2m}+X^2"></li></ul><h4 id="2-常见运算符">2.常见运算符</h4><table><thead><tr><th>符号</th><th>表达式</th><th>符号</th><th>表达式</th><th>符号</th><th>表达式</th></tr></thead><tbody><tr><td><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://math.jianshu.com/math?formula=%5Cpm" alt="\pm"></td><td>\pm</td><td><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://math.jianshu.com/math?formula=%5Ctimes" alt="\times"></td><td>\times</td><td><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://math.jianshu.com/math?formula=%5Cdiv" alt="\div"></td><td>\div</td></tr><tr><td><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://math.jianshu.com/math?formula=%5Ccdot" alt="\cdot"></td><td>\cdot</td><td><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://math.jianshu.com/math?formula=%5Cleq" alt="\leq"></td><td>\leq</td><td><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://math.jianshu.com/math?formula=%5Cgeq" alt="\geq"></td><td>\geq</td></tr><tr><td><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://math.jianshu.com/math?formula=%5Cneq" alt="\neq"></td><td>\neq</td><td><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://math.jianshu.com/math?formula=%5Capprox" alt="\approx"></td><td>\approx</td><td><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://math.jianshu.com/math?formula=%5Cequiv" alt="\equiv"></td><td>\equiv</td></tr><tr><td><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://math.jianshu.com/math?formula=%5Cin" alt="\in"></td><td>\in</td><td><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://math.jianshu.com/math?formula=%5Cnotin" alt="\notin"></td><td>\notin</td><td><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://math.jianshu.com/math?formula=%5Csubset" alt="\subset"></td><td>\subset</td></tr><tr><td><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://math.jianshu.com/math?formula=%5Csupset" alt="\supset"></td><td>\supset</td><td><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://math.jianshu.com/math?formula=%5Cbigcap" alt="\bigcap"></td><td>\bigcap</td><td><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://math.jianshu.com/math?formula=%5Cbigcup" alt="\bigcup"></td><td>\bigcup</td></tr></tbody></table><h4 id="3-特殊符号">3.特殊符号</h4><ul><li>求和符号: 使用<code>\sum</code> 转义表达求和符号,下限符号使用<code>_{m}</code>,上限符号使用<code>^\infty</code>, 如:  <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://math.jianshu.com/math?formula=%5Csum_%7Bm%3D0%7D%5E%5Cinfty" alt="\sum_{m=0}^\infty"></li><li>积分符号: <code>\int_0^1</code>转义表达积分符号, 如: <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://math.jianshu.com/math?formula=%5Cint_0%5E1" alt="\int_0^1"></li><li>极限符号: <code>\lim_{变量 \to 表达式} 表达式</code>, 如 <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://math.jianshu.com/math?formula=%5Clim_%7B1%20%5Cto%205%7D%20%E8%A1%A8%E8%BE%BE%E5%BC%8F" alt="\lim_{1 \to 5} 表达式"></li><li>向量符号: <code>\vec{a}</code>转义表达向量, 如: <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://math.jianshu.com/math?formula=%5Cvec%7Ba%7D" alt="\vec{a}"></li><li>空格符号: markdown支持四种空格<code>\, 、\;、\quad 和 \qquad</code></li></ul><h4 id="4-希腊字母的大小写">4.希腊字母的大小写</h4><p>希腊字母的大写使用首字母大写<code>\Gamma</code>转义,小写使用首字母小写<code>\gamma</code>转义, 公式表达结果为: <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://math.jianshu.com/math?formula=%5CGamma" alt="\Gamma">  和   <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://math.jianshu.com/math?formula=%5Cgamma" alt="\gamma"></p><h4 id="5-关于注释">5.关于注释</h4><ul><li>公式注释: 使用<code>\text{内容}</code>转义注释,公式表达结果为: <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://math.jianshu.com/math?formula=%5Ctext%20%7B%E5%85%AC%E5%BC%8F%E6%B3%A8%E9%87%8A%7D" alt="\text {公式注释}"></li><li>文字颜色: 使用<code>\color{颜色}{文字}</code>转义表达带颜色的文字,公式表达结果为:  <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://math.jianshu.com/math?formula=%5Ccolor%7Bgreen%7D%7B%E6%96%87%E5%AD%97%7D" alt="\color{green}{文字}"></li></ul><h4 id="6-分数">6.分数</h4><p>分数使用<code>\frac{part I}{part II}</code>转义表达,公式表达结果为: <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://math.jianshu.com/math?formula=%5Cfrac%7B(-1)%5Em%7D%7Bm!(m%20%2B%201)%7D" alt="\frac{(-1)^m}{m!(m + 1)}"></p><h4 id="7-公式中的大括号或大分隔符">7.公式中的大括号或大分隔符</h4><ul><li>在配对符号中.如公式中的括号使用<code>\left(</code>表达左括号,使用<code>\right)</code>转义表达向右的括号;如: <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://math.jianshu.com/math?formula=%5Cleft(%7B%5Cfrac%7Bx%7D%7B2%7D%20%7D%5Cright)" alt="\left({\frac{x}{2} }\right)"></li><li>在非配对符号中以<code>\left. 其他 \right符号</code> 或 <code>\left符号 其他 \right.</code> 表非配对的较大符号.如: <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://math.jianshu.com/math?formula=%5Cleft.%5Cfrac%7Bdu%7D%7Bdx%7D%5Cright%7C_%7Bx%3D0%7D" alt="\left.\frac{du}{dx}\right|_{x=0}"></li><li>注: 转义表达不需要<code>{ 和 }</code></li></ul><h4 id="8-上划线与下划线">8.上划线与下划线</h4><p>上划线使用<code>\overline{}</code>转义表达,下划线使用<code>\underline{}</code>转义表达,公式表达结果为: <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://math.jianshu.com/math?formula=%5Coverline%7Ba%2Bb%2Bc%2Bd%7D" alt="\overline{a+b+c+d}">和<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://math.jianshu.com/math?formula=%5Cunderline%7Ba%2Bb%2Bc%2Bd%7D" alt="\underline{a+b+c+d}"></p><h4 id="9-开根号">9.开根号</h4><p>多次方根使用<code>\sqrt[n]{x}</code>,其中<code>n</code>表示根的次数,<code>x</code>表示被开方项,公式表达结果为: <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://math.jianshu.com/math?formula=%5Csqrt%5Bn%5D%7B3%7D" alt="\sqrt[n]{3}"></p><h4 id="10-方程组">10.方程组</h4><p>1.表达方式一: 使用<code>\begin{array}{c} 表达式一\\表达式二... \end{array}</code><br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://math.jianshu.com/math?formula=%5Cleft%5C%7B%20%5Cbegin%7Barray%7D%20%7Ba%7D%20a_1x%2Bb_1y%2Bc_1z%3Dd_1%20%5C%5C%20a_2x%2Bb_2y%2Bc_2z%3Dd_2%20%5Cend%7Barray%7D%20%5Cright." alt="\left{ \begin{array} {a} a_1x+b_1y+c_1z=d_1 \ a_2x+b_2y+c_2z=d_2 \end{array} \right."><br>2.表达方式二: 使用<code>\begin{cases}…\end{cases}</code><br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://math.jianshu.com/math?formula=f(n)%20%3D%20%5Cbegin%7Bcases%7D%20%5Cfrac%7Bn%7D%7B2%7D%2C%20%26%20%5Ctext%7Bif%20%24n%24%20is%20even%7D%20%5C%5C%5B2ex%5D%203n%2B1%2C%20%26%20%5Ctext%7Bif%20%24n%24%20is%20odd%7D%20%5Cend%7Bcases%7D" alt="f(n) = \begin{cases} \frac{n}{2}, &amp; \text{if $n$ is even} \[2ex] 3n+1, &amp; \text{if $n$ is odd} \end{cases}"><br>注: 关于<code>\\[2ex]</code>一个 [ex] 指一个 “X-Height”，即x字母高度。可以根据情况指定多个 [ex]，如 [3ex]、[4ex] 等。 其实可以在任何地方使用 [2ex] 语句，只要你觉得合适。</p><h4 id="12-使用HTML语法表达数学公式">12.使用HTML语法表达数学公式</h4><ul><li>上标与下标的表达: 使用标签<code>&lt;sub&gt;</code>和<code>&lt;sup&gt;</code>表达, 表达结果为: text 与text</li><li>上划线表达: 使用标签<code>&lt;SPAN style=&quot;TEXT-DECORATION: overline&quot;&gt;X&lt;/SPAN&gt;</code>表达,表达结果为: <SPAN style="TEXT-DECORATION: overline">X</SPAN></li></ul><h4 id="13-补充">13.补充</h4><p>对于部分符号无法用 markdown 的公式表达,可以使用 <code>\符号</code> 转义表达,如 <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://math.jianshu.com/math?formula=%5C%25" alt="%">等</p><p>作者：地平线上的背影</p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BFS</title>
      <link href="/2020/081218898.html"/>
      <url>/2020/081218898.html</url>
      
        <content type="html"><![CDATA[<h1>bfs模板</h1><pre class=" language-language-c++"><code class="language-language-c++">const int N=10010;//看数据多大pair<int,int> q[N];#define x first#define y firstbool st[N][N];int g[N][N];int dx[4]={},dy[4]={};int bfs(int n,int m){  int hh=0,tt=0;  q[0]={};//这里面存的是一个点 具体问题具体分析  st[][]=true;//最开始的一个点遍历过了  while(hh<=tt){pair<int,int> t=q[hh++];    for(int i=0;i<4;i++){      int x=t.x+dx[i],y=t.y+dy[i];      if(check())//不满足的条件就跳过        continue;      q[++tt]={x,y};//新加入队列      st[x][y]=true;//标记访问过    }  }}int main(){}</code></pre><h2 id="抓住那头牛">抓住那头牛</h2><p><a href="https://www.acwing.com/problem/content/1102/" target="_blank" rel="noopener">题目链接</a></p><pre class=" language-language-c++"><code class="language-language-c++">农夫知道一头牛的位置，想要抓住它。农夫和牛都位于数轴上，农夫起始位于点 N，牛位于点 K。农夫有两种移动方式：从 X 移动到 X−1 或 X+1，每次移动花费一分钟从 X 移动到 2∗X，每次移动花费一分钟假设牛没有意识到农夫的行动，站在原地不动。农夫最少要花多少时间才能抓住牛？输入格式共一行，包含两个整数N和K。输出格式输出一个整数，表示抓到牛所花费的最少时间。数据范围0≤N,K≤105输入样例：5 17输出样例：4</code></pre><pre class=" language-language-c++"><code class="language-language-c++">#include<iostream>#include<stdio.h>#include<cstring>using namespace std;const int N=2e5+10;int dist[N];int q[N];int n,k;int bfs(){    memset(dist,-1,sizeof dist);    dist[n]=0;    int hh=0,tt=0;    q[0]=n;    while(hh<=tt){        int t=q[hh++];        if(t==k) return dist[t];        if(t+1<N&&dist[t+1]==-1)        {            dist[t+1]=dist[t]+1;            q[++tt]=t+1;        }        if(t-1>=0&&dist[t-1]==-1)        {            dist[t-1]=dist[t]+1;            q[++tt]=t-1;        }        if(t*2<N&&dist[t*2]==-1)        {            dist[t*2]=dist[t]+1;            q[++tt]=2*t;;        }    }    return 0;}int main(){    cin>>n>>k; printf("%d\n",bfs());}</code></pre><h2 id="走迷宫">走迷宫</h2><p><a href="https://www.acwing.com/problem/content/846/" target="_blank" rel="noopener">题目链接</a></p><pre class=" language-language-c"><code class="language-language-c">给定一个n*m的二维整数数组，用来表示一个迷宫，数组中只包含0或1，其中0表示可以走的路，1表示不可通过的墙壁。最初，有一个人位于左上角(1, 1)处，已知该人每次可以向上、下、左、右任意一个方向移动一个位置。请问，该人从左上角移动至右下角(n, m)处，至少需要移动多少次。数据保证(1, 1)处和(n, m)处的数字为0，且一定至少存在一条通路。输入格式第一行包含两个整数n和m。接下来n行，每行包含m个整数（0或1），表示完整的二维数组迷宫。输出格式输出一个整数，表示从左上角移动至右下角的最少移动次数。数据范围1≤n,m≤100输入样例：5 50 1 0 0 00 1 0 1 00 0 0 0 00 1 1 1 00 0 0 1 0输出样例：8</code></pre><pre class=" language-language-c++"><code class="language-language-c++">#include<cstdio>#include<iostream>#include<queue>using namespace std;int nx[4] = {-1,1,0,0},ny[4] = {0,0,-1,1},g[110][110];int step[110][110];pair<int,int> q[110*110];int bfs(int n,int m){    int hh=0,tt=0;    q[0]={0,0};    while(hh<=tt){        auto t = q[hh++];        int k = step[t.first][t.second];        if(t.first==n-1&&t.second==m-1) return k;        for(int i = 0;i < 4;i++){            int x = t.first + nx[i],y = t.second + ny[i];            if(step[x][y]==0&&g[x][y]==0&&x>=0&&y>=0&&x<n&&y<m){             q[++tt]={x,y};                step[x][y] = k+1;            }        }    }}int main(){    int n,m;    cin>>n>>m;    for(int i = 0;i < n;i++){        for(int j = 0;j <m;j++){            cin>>g[i][j];        }    }    printf("%d\n",bfs(n,m));}</code></pre><h2 id="迷宫问题">迷宫问题</h2><p><a href="https://www.acwing.com/problem/content/1078/" target="_blank" rel="noopener">题目链接</a></p><pre><code>给定一个 n×n 的二维数组，如下所示：int maze[5][5] = {0, 1, 0, 0, 0,0, 1, 0, 1, 0,0, 0, 0, 0, 0,0, 1, 1, 1, 0,0, 0, 0, 1, 0,};它表示一个迷宫，其中的1表示墙壁，0表示可以走的路，只能横着走或竖着走，不能斜着走，要求编程序找出从左上角到右下角的最短路线。数据保证至少存在一条从左上角走到右下角的路径。输入格式第一行包含整数 n。接下来 n 行，每行包含 n 个整数 0 或 1，表示迷宫。输出格式输出从左上角到右下角的最短路线，如果答案不唯一，输出任意一条路径均可。按顺序，每行输出一个路径中经过的单元格的坐标，左上角坐标为 (0,0)，右下角坐标为 (n−1,n−1)。数据范围0≤n≤1000输入样例：50 1 0 0 00 1 0 1 00 0 0 0 00 1 1 1 00 0 0 1 0输出样例：0 01 02 02 12 22 32 43 44 4</code></pre><pre class=" language-language-c++"><code class="language-language-c++">#include<iostream>#include<stdio.h>using namespace std;const int N=1010,M=N*N;int a[N][N],n;#define x first#define y secondbool st[N][N];pair<int,int> q[M];pair<int,int> pre[N][N];int dx[4]={-1,1,0,0},dy[4]={0,0,-1,1};void bfs(){    int hh=0,tt=0;    q[0]={n-1,n-1};    st[n-1][n-1]=true;    while(hh<=tt){        pair<int,int> t=q[hh++];        for(int i=0;i<4;i++)        {            int c=t.x+dx[i],d=t.y+dy[i];            if(a[c][d]==1||c<0||c>=n||d>=n||d<0||st[c][d]==true)continue;            q[++tt]={c,d};            pre[c][d]={t.x,t.y};            st[c][d]=true;        }    }}int main(){    cin>>n;    for(int i=0;i<n;i++)    for(int j=0;j<n;j++)    cin>>a[i][j];    bfs();    pair<int,int> end={0,0};    printf("0 0\n");    while(end.x!=n-1||end.y!=n-1){        printf("%d %d\n",pre[end.x][end.y].x,pre[end.x][end.y].y);        int x=end.x,y=end.y;        end.x=pre[x][y].x,end.y=pre[x][y].y;    }    return 0;}</code></pre><h2 id="武士风度的牛">武士风度的牛</h2><p><a href="https://www.acwing.com/problem/content/190/" target="_blank" rel="noopener">题目链接</a></p><pre class=" language-language-c"><code class="language-language-c">农民John有很多牛，他想交易其中一头被Don称为The Knight的牛。这头牛有一个独一无二的超能力，在农场里像Knight一样地跳（就是我们熟悉的象棋中马的走法）。虽然这头神奇的牛不能跳到树上和石头上，但是它可以在牧场上随意跳，我们把牧场用一个x，y的坐标图来表示。这头神奇的牛像其它牛一样喜欢吃草，给你一张地图，上面标注了The Knight的开始位置，树、灌木、石头以及其它障碍的位置，除此之外还有一捆草。现在你的任务是，确定The Knight要想吃到草，至少需要跳多少次。The Knight的位置用’K’来标记，障碍的位置用’*’来标记，草的位置用’H’来标记。这里有一个地图的例子：             11 | . . . . . . . . . .             10 | . . . . * . . . . .              9 | . . . . . . . . . .              8 | . . . * . * . . . .              7 | . . . . . . . * . .              6 | . . * . . * . . . H              5 | * . . . . . . . . .              4 | . . . * . . . * . .              3 | . K . . . . . . . .              2 | . . . * . . . . . *              1 | . . * . . . . * . .              0 ----------------------                                    1                0 1 2 3 4 5 6 7 8 9 0The Knight 可以按照下图中的A,B,C,D…这条路径用5次跳到草的地方（有可能其它路线的长度也是5）：             11 | . . . . . . . . . .             10 | . . . . * . . . . .              9 | . . . . . . . . . .              8 | . . . * . * . . . .              7 | . . . . . . . * . .              6 | . . * . . * . . . F<              5 | * . B . . . . . . .              4 | . . . * C . . * E .              3 | .>A . . . . D . . .              2 | . . . * . . . . . *              1 | . . * . . . . * . .              0 ----------------------                                    1                0 1 2 3 4 5 6 7 8 9 0注意： 数据保证一定有解。输入格式第1行： 两个数，表示农场的列数C(C<=150)和行数R(R<=150)。第2..R+1行: 每行一个由C个字符组成的字符串，共同描绘出牧场地图。输出格式一个整数，表示跳跃的最小次数。输入样例：10 11..............*..................*.*...........*....*..*...H*............*...*...K...........*.....*..*....*..输出样例：5</code></pre><pre class=" language-language-c++"><code class="language-language-c++">#include<iostream>#include<algorithm>#include<stdio.h>#include<cstring>using namespace std;int n,m;#define x first#define y secondconst int N=200,M=N*N;char g[N][N];int map[N][N];pair<int,int> q[M],st,ed;int ans=0;int dx[8]={-1,-2,-2,-1,1,2,2,1},dy[8]={-2,-1,1,2,2,1,-1,-2};int bfs(){    int hh=0,tt=0;    memset(map,-1,sizeof map);    q[0]={st.x,st.y};    map[st.x][st.y]=0;   while(hh<=tt){       pair<int,int> t=q[hh++];       int ans=map[t.x][t.y];       if(t.x==ed.x&&t.y==ed.y) return map[t.x][t.y];       for(int i =0;i<8;i++){          int c=t.x+dx[i],d=t.y+dy[i];           if(map[c][d]!=-1||c<0||c>=n||d<0||d>=m||g[c][d]=='*')continue;           q[++tt]={c,d};           map[c][d]=map[t.x][t.y]+1;       }   }    return 0;}int main(){    cin>>m>>n;    for(int i=0;i<n;i++)    for(int j=0;j<m;j++){    cin>>g[i][j];    if(g[i][j]=='K')    st.x=i,st.y=j;    if(g[i][j]=='H')    ed.x=i,ed.y=j;    }   printf("%d\n",bfs());}</code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithmBFS </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
