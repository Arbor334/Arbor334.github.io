<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Markdown</title>
      <link href="/2020/081217683.html"/>
      <url>/2020/081217683.html</url>
      
        <content type="html"><![CDATA[<h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><p>井号 “#” 加 一个空格” “</p><p>一直可以到6级标题</p><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><p><strong>hello，world</strong>    变成粗体 两边各加两个*号</p><p><em>hello,world</em>     变成斜体 两边各加一个*号</p><p><strong><em>hello,world</em></strong>   加粗斜体 两边各加上 ***号</p><p><del>hello,world</del>     两边各加上两个波浪号</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><blockquote><p>大于号 + 空格</p></blockquote><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><hr><p>“—“ 三个杠 就可以</p><hr><p>“***”三个星也可以</p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>![截图](C:\Users\QZJ_2020\Pictures\Saved Pictures\t017dd4fea10b244ac9.jpg)</p><blockquote><p><img src="">  感叹号   [图片的名字]   ()</p></blockquote><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><hr><p><a href="https://www.cnblogs.com/">点击进入我的博客</a></p><blockquote><p>[名字]  (链接地址)</p></blockquote><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><hr><ol><li><p>A</p></li><li><p>B</p></li><li><p>C</p><blockquote><p>“1.空格”</p></blockquote></li></ol><ul><li>A</li><li>B</li><li>C</li></ul><blockquote><p>“减号   空格  出来小点  “</p></blockquote><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><hr><table><thead><tr><th>名字</th><th>性别</th><th>生日</th></tr></thead><tbody><tr><td>张三</td><td>男</td><td>1990.1.1</td></tr></tbody></table><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> main（String args<span class="token punctuation">[</span><span class="token punctuation">]</span>）</code></pre><blockquote><p><strong>“``` “</strong>  然后加入 代码的名字  c c++  Java</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BFS</title>
      <link href="/2020/081218898.html"/>
      <url>/2020/081218898.html</url>
      
        <content type="html"><![CDATA[<h1 id="bfs模板"><a href="#bfs模板" class="headerlink" title="bfs模板"></a>bfs模板</h1><pre class=" language-c++"><code class="language-c++">const int N=10010;//看数据多大pair<int,int> q[N];#define x first#define y firstbool st[N][N];int g[N][N];int dx[4]=&#123;&#125;,dy[4]=&#123;&#125;;int bfs(int n,int m)&#123;  int hh=0,tt=0;  q[0]=&#123;&#125;;//这里面存的是一个点 具体问题具体分析  st[][]=true;//最开始的一个点遍历过了  while(hh<=tt)&#123;pair<int,int> t=q[hh++];    for(int i=0;i<4;i++)&#123;      int x=t.x+dx[i],y=t.y+dy[i];      if(check())//不满足的条件就跳过        continue;      q[++tt]=&#123;x,y&#125;;//新加入队列      st[x][y]=true;//标记访问过    &#125;  &#125;&#125;int main()&#123;&#125;</code></pre><h2 id="抓住那头牛"><a href="#抓住那头牛" class="headerlink" title="抓住那头牛"></a>抓住那头牛</h2><p><a href="https://www.acwing.com/problem/content/1102/">题目链接</a></p><pre class=" language-c++"><code class="language-c++">农夫知道一头牛的位置，想要抓住它。农夫和牛都位于数轴上，农夫起始位于点 N，牛位于点 K。农夫有两种移动方式：从 X 移动到 X−1 或 X+1，每次移动花费一分钟从 X 移动到 2∗X，每次移动花费一分钟假设牛没有意识到农夫的行动，站在原地不动。农夫最少要花多少时间才能抓住牛？输入格式共一行，包含两个整数N和K。输出格式输出一个整数，表示抓到牛所花费的最少时间。数据范围0≤N,K≤105输入样例：5 17输出样例：4</code></pre><pre class=" language-c++"><code class="language-c++">#include<iostream>#include<stdio.h>#include<cstring>using namespace std;const int N=2e5+10;int dist[N];int q[N];int n,k;int bfs()&#123;    memset(dist,-1,sizeof dist);    dist[n]=0;    int hh=0,tt=0;    q[0]=n;    while(hh<=tt)&#123;        int t=q[hh++];        if(t==k) return dist[t];        if(t+1<N&&dist[t+1]==-1)        &#123;            dist[t+1]=dist[t]+1;            q[++tt]=t+1;        &#125;        if(t-1>=0&&dist[t-1]==-1)        &#123;            dist[t-1]=dist[t]+1;            q[++tt]=t-1;        &#125;        if(t*2<N&&dist[t*2]==-1)        &#123;            dist[t*2]=dist[t]+1;            q[++tt]=2*t;;        &#125;    &#125;    return 0;&#125;int main()&#123;    cin>>n>>k; printf("%d\n",bfs());&#125;</code></pre><h2 id="走迷宫"><a href="#走迷宫" class="headerlink" title="走迷宫"></a>走迷宫</h2><p><a href="https://www.acwing.com/problem/content/846/">题目链接</a></p><pre class=" language-c++"><code class="language-c++">给定一个n*m的二维整数数组，用来表示一个迷宫，数组中只包含0或1，其中0表示可以走的路，1表示不可通过的墙壁。最初，有一个人位于左上角(1, 1)处，已知该人每次可以向上、下、左、右任意一个方向移动一个位置。请问，该人从左上角移动至右下角(n, m)处，至少需要移动多少次。数据保证(1, 1)处和(n, m)处的数字为0，且一定至少存在一条通路。输入格式第一行包含两个整数n和m。接下来n行，每行包含m个整数（0或1），表示完整的二维数组迷宫。输出格式输出一个整数，表示从左上角移动至右下角的最少移动次数。数据范围1≤n,m≤100输入样例：5 50 1 0 0 00 1 0 1 00 0 0 0 00 1 1 1 00 0 0 1 0输出样例：8</code></pre><pre class=" language-c++"><code class="language-c++">#include<cstdio>#include<iostream>#include<queue>using namespace std;int nx[4] = &#123;-1,1,0,0&#125;,ny[4] = &#123;0,0,-1,1&#125;,g[110][110];int step[110][110];pair<int,int> q[110*110];int bfs(int n,int m)&#123;    int hh=0,tt=0;    q[0]=&#123;0,0&#125;;    while(hh<=tt)&#123;        auto t = q[hh++];        int k = step[t.first][t.second];        if(t.first==n-1&&t.second==m-1) return k;        for(int i = 0;i < 4;i++)&#123;            int x = t.first + nx[i],y = t.second + ny[i];            if(step[x][y]==0&&g[x][y]==0&&x>=0&&y>=0&&x<n&&y<m)&#123;             q[++tt]=&#123;x,y&#125;;                step[x][y] = k+1;            &#125;        &#125;    &#125;&#125;int main()&#123;    int n,m;    cin>>n>>m;    for(int i = 0;i < n;i++)&#123;        for(int j = 0;j <m;j++)&#123;            cin>>g[i][j];        &#125;    &#125;    printf("%d\n",bfs(n,m));&#125;</code></pre><h2 id="迷宫问题"><a href="#迷宫问题" class="headerlink" title="迷宫问题"></a>迷宫问题</h2><p><a href="https://www.acwing.com/problem/content/1078/">题目链接</a></p><pre><code>给定一个 n×n 的二维数组，如下所示：int maze[5][5] = &amp;#123;0, 1, 0, 0, 0,0, 1, 0, 1, 0,0, 0, 0, 0, 0,0, 1, 1, 1, 0,0, 0, 0, 1, 0,&amp;#125;;它表示一个迷宫，其中的1表示墙壁，0表示可以走的路，只能横着走或竖着走，不能斜着走，要求编程序找出从左上角到右下角的最短路线。数据保证至少存在一条从左上角走到右下角的路径。输入格式第一行包含整数 n。接下来 n 行，每行包含 n 个整数 0 或 1，表示迷宫。输出格式输出从左上角到右下角的最短路线，如果答案不唯一，输出任意一条路径均可。按顺序，每行输出一个路径中经过的单元格的坐标，左上角坐标为 (0,0)，右下角坐标为 (n−1,n−1)。数据范围0≤n≤1000输入样例：50 1 0 0 00 1 0 1 00 0 0 0 00 1 1 1 00 0 0 1 0输出样例：0 01 02 02 12 22 32 43 44 4</code></pre><pre class=" language-c++"><code class="language-c++">#include<iostream>#include<stdio.h>using namespace std;const int N=1010,M=N*N;int a[N][N],n;#define x first#define y secondbool st[N][N];pair<int,int> q[M];pair<int,int> pre[N][N];int dx[4]=&#123;-1,1,0,0&#125;,dy[4]=&#123;0,0,-1,1&#125;;void bfs()&#123;    int hh=0,tt=0;    q[0]=&#123;n-1,n-1&#125;;    st[n-1][n-1]=true;    while(hh<=tt)&#123;        pair<int,int> t=q[hh++];        for(int i=0;i<4;i++)        &#123;            int c=t.x+dx[i],d=t.y+dy[i];            if(a[c][d]==1||c<0||c>=n||d>=n||d<0||st[c][d]==true)continue;            q[++tt]=&#123;c,d&#125;;            pre[c][d]=&#123;t.x,t.y&#125;;            st[c][d]=true;        &#125;    &#125;&#125;int main()&#123;    cin>>n;    for(int i=0;i<n;i++)    for(int j=0;j<n;j++)    cin>>a[i][j];    bfs();    pair<int,int> end=&#123;0,0&#125;;    printf("0 0\n");    while(end.x!=n-1||end.y!=n-1)&#123;        printf("%d %d\n",pre[end.x][end.y].x,pre[end.x][end.y].y);        int x=end.x,y=end.y;        end.x=pre[x][y].x,end.y=pre[x][y].y;    &#125;    return 0;&#125;</code></pre><h2 id="武士风度的牛"><a href="#武士风度的牛" class="headerlink" title="武士风度的牛"></a>武士风度的牛</h2><p><a href="https://www.acwing.com/problem/content/190/">题目链接</a></p><pre class=" language-c++"><code class="language-c++">农民John有很多牛，他想交易其中一头被Don称为The Knight的牛。这头牛有一个独一无二的超能力，在农场里像Knight一样地跳（就是我们熟悉的象棋中马的走法）。虽然这头神奇的牛不能跳到树上和石头上，但是它可以在牧场上随意跳，我们把牧场用一个x，y的坐标图来表示。这头神奇的牛像其它牛一样喜欢吃草，给你一张地图，上面标注了The Knight的开始位置，树、灌木、石头以及其它障碍的位置，除此之外还有一捆草。现在你的任务是，确定The Knight要想吃到草，至少需要跳多少次。The Knight的位置用’K’来标记，障碍的位置用’*’来标记，草的位置用’H’来标记。这里有一个地图的例子：             11 | . . . . . . . . . .             10 | . . . . * . . . . .              9 | . . . . . . . . . .              8 | . . . * . * . . . .              7 | . . . . . . . * . .              6 | . . * . . * . . . H              5 | * . . . . . . . . .              4 | . . . * . . . * . .              3 | . K . . . . . . . .              2 | . . . * . . . . . *              1 | . . * . . . . * . .              0 ----------------------                                    1                0 1 2 3 4 5 6 7 8 9 0The Knight 可以按照下图中的A,B,C,D…这条路径用5次跳到草的地方（有可能其它路线的长度也是5）：             11 | . . . . . . . . . .             10 | . . . . * . . . . .              9 | . . . . . . . . . .              8 | . . . * . * . . . .              7 | . . . . . . . * . .              6 | . . * . . * . . . F<              5 | * . B . . . . . . .              4 | . . . * C . . * E .              3 | .>A . . . . D . . .              2 | . . . * . . . . . *              1 | . . * . . . . * . .              0 ----------------------                                    1                0 1 2 3 4 5 6 7 8 9 0注意： 数据保证一定有解。输入格式第1行： 两个数，表示农场的列数C(C<=150)和行数R(R<=150)。第2..R+1行: 每行一个由C个字符组成的字符串，共同描绘出牧场地图。输出格式一个整数，表示跳跃的最小次数。输入样例：10 11..............*..................*.*...........*....*..*...H*............*...*...K...........*.....*..*....*..输出样例：5</code></pre><pre class=" language-c++"><code class="language-c++">#include<iostream>#include<algorithm>#include<stdio.h>#include<cstring>using namespace std;int n,m;#define x first#define y secondconst int N=200,M=N*N;char g[N][N];int map[N][N];pair<int,int> q[M],st,ed;int ans=0;int dx[8]=&#123;-1,-2,-2,-1,1,2,2,1&#125;,dy[8]=&#123;-2,-1,1,2,2,1,-1,-2&#125;;int bfs()&#123;    int hh=0,tt=0;    memset(map,-1,sizeof map);    q[0]=&#123;st.x,st.y&#125;;    map[st.x][st.y]=0;   while(hh<=tt)&#123;       pair<int,int> t=q[hh++];       int ans=map[t.x][t.y];       if(t.x==ed.x&&t.y==ed.y) return map[t.x][t.y];       for(int i =0;i<8;i++)&#123;          int c=t.x+dx[i],d=t.y+dy[i];           if(map[c][d]!=-1||c<0||c>=n||d<0||d>=m||g[c][d]=='*')continue;           q[++tt]=&#123;c,d&#125;;           map[c][d]=map[t.x][t.y]+1;       &#125;   &#125;    return 0;&#125;int main()&#123;    cin>>m>>n;    for(int i=0;i<n;i++)    for(int j=0;j<m;j++)&#123;    cin>>g[i][j];    if(g[i][j]=='K')    st.x=i,st.y=j;    if(g[i][j]=='H')    ed.x=i,ed.y=j;    &#125;   printf("%d\n",bfs());&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithmBFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>prim</title>
      <link href="/2020/081126197.html"/>
      <url>/2020/081126197.html</url>
      
        <content type="html"><![CDATA[<h1 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h1><p><a href="https://www.acwing.com/problem/content/860/">模板题木链接</a></p><h2 id="Prim算法概括"><a href="#Prim算法概括" class="headerlink" title="Prim算法概括"></a>Prim算法概括</h2><blockquote><p>文字来源 蓝书 【算法竞赛进阶指南】</p><p>Prim算法总是维护最小生成树的一部分</p><p>适用于稠密图，尤其是完全图的最小生成树的求解</p><p>最初，只确定1号节点属于最小生成树</p><p>任意时间，设已经确定属于最小生成树节点的集合为T<br>                                         省余节点的集合为S</p><p>Prim找到 min x∈T，y∈S {z}</p><p>即：两个端点分别属于 S,T的权值的最小边，</p><p>把x从集合S 中删除，加入集合T中，并把 z 加入到答案中</p><p>维护数组d[], 若x∈S，d[x]表示节点x和节点T中的节点之间的权值的最小边。若x属于T，d[x]表示x被加入T是选出的最小边的权值</p></blockquote><h2 id="prim算法流程"><a href="#prim算法流程" class="headerlink" title="prim算法流程"></a>prim算法流程</h2><blockquote><p>【1】、先把数组d 赋值为正无穷</p><p>【2】、遍历n次 每次找到结合S中距离最近的点复制给 t</p><p>【3】、v[t]=true t边用过了</p><p>【4】、用 t 更新其他点到集合的距离</p></blockquote><h2 id="prim朴素算法代码"><a href="#prim朴素算法代码" class="headerlink" title="prim朴素算法代码"></a>prim朴素算法代码</h2><pre class=" language-c++"><code class="language-c++">using namespace std;const int N=3010;int a[N][N],d[N],n,m,ans;bool v[N];void prim()&#123;    memset(d,0x3f,sizeof d);    memset(v,0,sizeof v);    d[1]=0; //第一个点可以默认在T集合中    for(int i=1;i<n;i++)&#123; //遍历n次        int x=0;        for(int j=1;j<=n;j++)        if(!v[j]&&(x==0||d[j]<d[x]))x=j; //找到最小权值            v[x]=1; //x这个最小权值边用过了            for(int y=1;y<=n;y++) //更新点到集合T的距离            if(!v[y])d[y]=min(d[y],a[x][y]);    &#125;&#125;int main()&#123;    cin>>n>>m;    memset(a,0x3f,sizeof a); //用邻接矩阵存储 初始化都是不通的    for(int i=1;i<=n;i++) a[i][i]=0; //自己到自己为0    for(int i=1;i<=m;i++)    &#123; int x,y,z;        cin>>x>>y>>z;        a[x][y]=a[y][x]=min(a[x][y],z); //无向图 所以 x->y y->x都要存    &#125;    prim();    for(int i=2;i<=n;i++)ans+=d[i]; //d就是prim以后每次加如集合T的最小权值     if(ans>4990000) //(500-1)*10000     printf("impossible\n");    else    printf("%d\n",ans);&#125;</code></pre><blockquote><p>等待更新</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
